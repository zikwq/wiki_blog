
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="顺便考个研究生吧，万一考上了呐。">
      
      
      
        <link rel="canonical" href="https://zikwq.github.io/fpga/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%80%9A%E4%BF%A1/">
      
      
        <link rel="prev" href="../SPI%E5%8D%8F%E8%AE%AE/">
      
      
        <link rel="next" href="../FPGA%E5%AE%9E%E7%8E%B0CAN%E9%80%9A%E4%BF%A1/">
      
      
      <link rel="icon" href="https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/%E5%B0%8F%E6%81%B6%E9%AD%94%E7%8E%A9%E8%80%8D.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>千兆以太网通信 - 研究生日记</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC+-+local:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Sans SC - local";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="研究生日记" class="md-header__button md-logo" aria-label="研究生日记" data-md-component="logo">
      
  <img src="https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/%E5%B0%8F%E6%81%B6%E9%AD%94%E7%8E%A9%E8%80%8D.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            研究生日记
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              千兆以太网通信
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="blue"  aria-label="切换暗色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换暗色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0 8a5 5 0 0 1-5-5 5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5m0-12.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="blue"  aria-label="切换亮色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换亮色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9a3 3 0 0 1 3 3 3 3 0 0 1-3 3 3 3 0 0 1-3-3 3 3 0 0 1 3-3m0-4.5c5 0 9.27 3.11 11 7.5-1.73 4.39-6 7.5-11 7.5S2.73 16.39 1 12c1.73-4.39 6-7.5 11-7.5M3.18 12a9.821 9.821 0 0 0 17.64 0 9.821 9.821 0 0 0-17.64 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
      <div class="md-header__option">
  <div class="md-select">
    
    <button class="md-header__button md-icon" aria-label="选择当前语言">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.5 17.5 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2zm-2.62 7 1.62-4.33L19.12 17z"/></svg>
    </button>
    <div class="md-select__inner">
      <ul class="md-select__list">
        
          <li class="md-select__item">
            <a href="/" hreflang="zh" class="md-select__link">
              简体中文
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/en/" hreflang="en" class="md-select__link">
              English
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/es/" hreflang="es" class="md-select__link">
              Español
            </a>
          </li>
        
          <li class="md-select__item">
            <a href="/ar/" hreflang="ar" class="md-select__link">
              اللغة العربية
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/zikwq/zikwq.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../FFT%20IP%E6%A0%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="md-tabs__link">
          
  
    
  
  FPGA学习&实战

        </a>
      </li>
    
  

    
  

    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../%E5%8E%9F%E7%90%86%E5%9B%BE%26PCB%E8%AE%BE%E8%AE%A1/%E7%94%B5%E9%98%BB/" class="md-tabs__link">
          
  
    
  
  原理图&PCB设计

        </a>
      </li>
    
  

    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="研究生日记" class="md-nav__button md-logo" aria-label="研究生日记" data-md-component="logo">
      
  <img src="https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/%E5%B0%8F%E6%81%B6%E9%AD%94%E7%8E%A9%E8%80%8D.png" alt="logo">

    </a>
    研究生日记
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/zikwq/zikwq.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    FPGA学习&实战
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            FPGA学习&实战
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" checked>
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="">
            
  
  <span class="md-ellipsis">
    基础知识
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            基础知识
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1_1" id="__nav_2_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    常用IP核
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_1">
            <span class="md-nav__icon md-icon"></span>
            常用IP核
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../FFT%20IP%E6%A0%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FFT IP核使用方法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RAM%20IP%E6%A0%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RAM IP核使用方法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ROM%20IP%E6%A0%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ROM IP核使用方法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%87%AA%E5%AE%9A%E4%B9%89IP%E5%B0%81%E8%A3%85/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    自定义IP封装
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2_1_2" id="__nav_2_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    常用通信协议
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_1_2">
            <span class="md-nav__icon md-icon"></span>
            常用通信协议
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../I2C%E5%8D%8F%E8%AE%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    I2C协议
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RS485%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RS485串口协议
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SPI%E5%8D%8F%E8%AE%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SPI协议
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    千兆以太网通信
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    千兆以太网通信
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 千兆以太网
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. 千兆以太网">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 以太网基础知识
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1 以太网基础知识">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-phy" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.1 PHY芯片介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.1 PHY芯片介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 功能
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 工作原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 技术规格
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 应用场景
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5. 选型要点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-osi" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.2 OSI七层模型介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.2 OSI七层模型介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#osi" class="md-nav__link">
    <span class="md-ellipsis">
      OSI七层模型功能协议对照表
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-gmiirgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.3 GMII和RGMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.3 GMII和RGMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gmii" class="md-nav__link">
    <span class="md-ellipsis">
      GMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      主要特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      应用场景
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      RGMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RGMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      主要特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      应用场景
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gmii-vs-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      GMII vs RGMII
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      说明：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rgmii_1" class="md-nav__link">
    <span class="md-ellipsis">
      RGMII接口时序设计
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      数据包结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#udpicmptcparp" class="md-nav__link">
    <span class="md-ellipsis">
      UDP、ICMP、TCP和ARP之间的关系
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114-udpip" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.4 UDP首部校验和、IP首部校验和计算方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 项目框架和时序图绘制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-rgmiirgmii_recivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.3 RGMII接收模块代码编写：rgmii_recive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.3 RGMII接收模块代码编写：rgmii_recive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-ibuf" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.2 IBUF（输入缓冲器）原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133-bufgbufioio" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.3 BUFG（全局时钟缓冲器）、BUFIO（I/O时钟缓冲器）原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134-idelay" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.4 IDELAY原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#135-iddr" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.5 IDDR原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.6 RGMII接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#137" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.7 代码仿真代码与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-rgmiirgmii_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.4 RGMII发送模块代码编写：rgmii_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.4 RGMII发送模块代码编写：rgmii_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142-oddr" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.2 ODDR原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.3 RGMII发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#144" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.5 UDP协议栈架构设计及时钟规划
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#16-macmac_receivevv" class="md-nav__link">
    <span class="md-ellipsis">
      1.6 MAC接收模块代码编写：mac_receivev.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6 MAC接收模块代码编写：mac_receivev.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#161" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#162" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2 状态机逻辑讲解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6.2 状态机逻辑讲解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1621verilog" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.1状态机的Verilog实现步骤
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6.2.1状态机的Verilog实现步骤">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      （1）状态定义
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      （2）状态寄存器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      （3）下一状态逻辑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      （4）输出逻辑
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1622-1" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.2 应用案例1：自动贩卖机示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1623-2" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.3 应用案例2：交通信号灯示例
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#163-fifofifo" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.3 深入理解FIFO的底层资源（设置FIFO的位宽和深度即类型）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#164-gmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.4 GMII输入信号延迟处理逻辑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#165-sfdmaccrc" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.5 校验逻辑实现（前导码、SFD、MAC地址、crc数据校验内容）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#166-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.6 以太网数据帧分离（剥离有效数据和mac包头)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#167-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.7 MAC层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#168-mac_to_arp_ipv" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.8 mac_to_arp_ip.v模块编写
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#168" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.8 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#17-macmac_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.7 MAC发送模块代码编写：mac_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.7 MAC发送模块代码编写：mac_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.1 添加MAC头部
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#172" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.2 跨时钟域处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#173-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3 CRC校验(循环冗余校验)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.7.3 CRC校验(循环冗余校验)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1731-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.1 什么是 CRC？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1732-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.2 CRC 计算原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1733" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.3模块代码解析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1734" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.4完整计算流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1735" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.5 总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1736" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.6 实际使用时的便捷方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1737" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.7 模块代码解析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1738" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.8 完整代码工程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1739" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.9 代码仿真与验证
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#17310" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.10 关键问题回答
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#174-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.4 MAC层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#175" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.5 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#18-ipip_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.8 IP接收模块代码编写：ip_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.8 IP接收模块代码编写：ip_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#181" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.1 模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#182" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.2核心功能实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#183-ip" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.3 IP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#184" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#19-ipip_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.9 IP发送模块代码编写：ip_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.9 IP发送模块代码编写：ip_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#191" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.1 模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#192" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.2 核心代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#193-ip" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.3 IP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#194" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#110-udpudp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.10 UDP接收模块代码编写：udp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.10 UDP接收模块代码编写：udp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1101-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.1 UDP接收模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1102-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.2 UDP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1103" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.3 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#111-udpudp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.11 UDP发送模块代码编写：udp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.11 UDP发送模块代码编写：udp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1111-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.1 UDP发送模块简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1112-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.2 UDP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1113" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.3 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.12 ARP介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-arparp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.13 ARP接收模块代码编写：arp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.13 ARP接收模块代码编写：arp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1131-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.13.1 ARP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1132" class="md-nav__link">
    <span class="md-ellipsis">
      1.13.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114-arparp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.14 ARP发送模块代码编写：arp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.14 ARP发送模块代码编写：arp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1141-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.14.1 ARP层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1142" class="md-nav__link">
    <span class="md-ellipsis">
      1.14.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#115-arparp_dynamic_listv" class="md-nav__link">
    <span class="md-ellipsis">
      1.15 ARP动态列表模块编写arp_dynamic_list.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.15 ARP动态列表模块编写arp_dynamic_list.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1151-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.15.1 ARP动态列表代码
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#116-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16 ICMP协议介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.16 ICMP协议介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1161-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16.1 ICMP协议分类
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1162-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16.2. ICMP数据包的结构与实现流程
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#117-icmpicmp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.17 ICMP接收模块代码编写：icmp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.17 ICMP接收模块代码编写：icmp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1171-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.17.1 ICMP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1172" class="md-nav__link">
    <span class="md-ellipsis">
      1.17.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#118-icmpicmp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.18 ICMP发送模块代码编写：icmp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.18 ICMP发送模块代码编写：icmp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1181-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.18.1 ICMP层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1182" class="md-nav__link">
    <span class="md-ellipsis">
      1.18.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../FPGA%E5%AE%9E%E7%8E%B0CAN%E9%80%9A%E4%BF%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FPGA实现CAN通信
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDMI%E6%98%BE%E7%A4%BA%E5%99%A8%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HDMI显示器驱动设计
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%B7%AE%E5%88%86%E5%AF%B9%E5%92%8C%E5%B7%AE%E5%88%86%E4%BF%A1%E5%8F%B7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    差分对和差分信号
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../VGA%E6%98%BE%E7%A4%BA%E5%99%A8%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VGA显示器驱动设计
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../VGA%E6%98%BE%E7%A4%BA%E5%99%A8%E9%A9%B1%E5%8A%A8--%E5%AD%97%E7%AC%A6%E6%B8%B8%E8%B5%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VGA显示器驱动--字符游走
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9F%BA%E4%BA%8EROM%E7%9A%84VGA%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    基于ROM的VGA图像显示
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_3" >
        
          
          <label class="md-nav__link" for="__nav_2_1_3" id="__nav_2_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    DDR3
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_3">
            <span class="md-nav__icon md-icon"></span>
            DDR3
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../01_AXI4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    01_AXI4基础知识
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02_AXI4_Lite%E7%9A%84%E8%AF%BB%E5%86%99%E9%80%9A%E9%81%93%E5%92%8C%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    02_AXI4_Lite的读写通道和仿真代码的实现
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DDR3%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%AA%8C%E8%AF%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DDR3读写控制器的设计与验证
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_4" >
        
          
          <label class="md-nav__link" for="__nav_2_1_4" id="__nav_2_1_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    AD外设
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_4">
            <span class="md-nav__icon md-icon"></span>
            AD外设
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../AD%E5%A4%96%E8%AE%BE%E7%9A%84%E5%8E%9F%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AD外设的原理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AE%80%E6%98%93%E9%A2%91%E7%8E%87%E8%AE%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%AA%8C%E8%AF%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    简易频率计的设计与验证
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%97%E7%A4%BA%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数字示波器设计
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_5" >
        
          
          <label class="md-nav__link" for="__nav_2_1_5" id="__nav_2_1_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    存储器
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_5">
            <span class="md-nav__icon md-icon"></span>
            存储器
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ROM%E3%80%81RAM%E3%80%81FIFO%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E3%80%81%E5%8C%BA%E5%88%86%E3%80%81%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ROM、RAM、FIFO知识点整理、区分、应用案例
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_6" >
        
          
          <label class="md-nav__link" for="__nav_2_1_6" id="__nav_2_1_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    状态机
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_6">
            <span class="md-nav__icon md-icon"></span>
            状态机
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    状态机相关知识
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_7" >
        
          
          <label class="md-nav__link" for="__nav_2_1_7" id="__nav_2_1_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    时序设计
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_7">
            <span class="md-nav__icon md-icon"></span>
            时序设计
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    时序约束
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E9%9C%80%E8%A6%81%E6%BB%9E%E5%90%8E%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    为什么时序逻辑需要滞后一个时钟周期
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_8" >
        
          
          <label class="md-nav__link" for="__nav_2_1_8" id="__nav_2_1_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数字电路基础
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_8">
            <span class="md-nav__icon md-icon"></span>
            数字电路基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数字电路基础
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_9" >
        
          
          <label class="md-nav__link" for="__nav_2_1_9" id="__nav_2_1_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    ZYNQ专题
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_9">
            <span class="md-nav__icon md-icon"></span>
            ZYNQ专题
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ZYNQ%E4%BB%8B%E7%BB%8D/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ZYNQ的介绍
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_10" >
        
          
          <label class="md-nav__link" for="__nav_2_1_10" id="__nav_2_1_10_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    其他
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_10">
            <span class="md-nav__icon md-icon"></span>
            其他
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%98%BE%E7%A4%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DHT11温湿度显示
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9B%E7%A7%8D%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并行数据转为串行数据
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    电路的动态特性
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E9%80%9F%E5%85%89%E9%80%9A%E4%BF%A1%E9%A1%B9%E7%9B%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高速光通信项目
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E9%80%9F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高速接口的学习
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%95%B4%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    锁存器和触发器的理解与整理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数码管动态显示
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    笔试题目汇总
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BF%AE%E6%94%B9%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    使用python修改图像格式
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../FPGA%E4%B8%8ECPLD%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FPGA与CPLD的区别与联系
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../TestBench%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TestBench编写技巧
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../fpga%E7%9A%84mt9v034%E6%91%84%E5%83%8F%E5%A4%B4%E9%85%8D%E7%BD%AE%E5%8F%8Ahdmi%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    fpga的mt9v034摄像头配置及hdmi显示输出
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%BA%E4%BB%80%E4%B9%88FPGA%E7%9A%84%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E4%BC%9A%E5%BB%B6%E6%97%B6%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%EF%BC%8C%E8%80%8C%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E5%BB%B6%E6%97%B6%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E5%91%90%EF%BC%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    为什么FPGA的阻塞赋值会延时一个时钟周期，而在某些情况下不延时一个时钟周期呐？
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    笔试题目练习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            笔试题目练习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_1" id="__nav_2_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    牛客网
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_1">
            <span class="md-nav__icon md-icon"></span>
            牛客网
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%9D%A2%E8%AF%95%E9%A2%98/59_%E6%A0%B9%E6%8D%AERTL%E5%9B%BE%E7%BC%96%E5%86%99Verilog%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    题目59_根据RTL图编写Verilog程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%9D%A2%E8%AF%95%E9%A2%98/60_%E4%BD%BF%E7%94%A8%E6%8F%A1%E6%89%8B%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    题目60_使用握手信号实现跨时钟域数据传输
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%9D%A2%E8%AF%95%E9%A2%98/IIC%E4%B8%8ESCCB%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    IIC与SCCB协议的联系与区别
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    面试实战
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2" id="__nav_2_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    HDLBits练习
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            HDLBits练习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_1" id="__nav_2_2_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_1">
            <span class="md-nav__icon md-icon"></span>
            Getting Started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Getting_Started/Getting_Started/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Getting_Started/Output_Zero/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Output Zero
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2" id="__nav_2_2_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Verilog Language
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            Verilog Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2_1" id="__nav_2_2_2_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Basics
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2_1">
            <span class="md-nav__icon md-icon"></span>
            Basics
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Simple_wire/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple wire
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Four_wires/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Four wires
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Inverter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Inverter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/AND_gate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AND gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/NOR_gate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NOR gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/XNOR_gate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    XNOR gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Declaring_wires/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Declaring wires
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/7458_chip/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7458 chip
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2_2" id="__nav_2_2_2_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Vectors
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            Vectors
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Vectors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Vectors_in_more_detail/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vectors in more detail
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Vector_part_select/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vector part select
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Bitwise_operators/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bitwise operators
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Four-input_gates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Four input gates
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Vector_concatenation_operator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vector concatenation operator
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Vector_reversal_1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vector reversal 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Replication_operator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Replication operator
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/More_replication/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    More replication
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2_3" id="__nav_2_2_2_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Modules:Hierarchy
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2_3">
            <span class="md-nav__icon md-icon"></span>
            Modules:Hierarchy
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Modules/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Modules
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Connecting_ports_by_position/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Connecting ports by position
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Connecting_ports_by_name/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Connecting ports by name
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Three_modules/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Three modules
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Modules_and_vectors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Modules and vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Adder_1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adder 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Adder_2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adder 2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Carry-select_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Carry select adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Adder-subtractor/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adder subtractor
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2_4" id="__nav_2_2_2_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Procedures
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2_4">
            <span class="md-nav__icon md-icon"></span>
            Procedures
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Always_blocks_%28combinational%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Always blocks (combinational)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Always_blocks_%28clocked%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Always blocks (clocked)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/If_statement/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    If statement
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/If_statement_latches/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    If statement latches
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Case_statement/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Case statement
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Priority_encoder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Priority encoder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Priority_encoder_with_casez/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Priority encoder with casez
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Avoiding_latches/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Avoiding latches
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_2_5" id="__nav_2_2_2_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    More Verilog Features
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_2_5">
            <span class="md-nav__icon md-icon"></span>
            More Verilog Features
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Conditional_ternary_operator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Conditional ternary operator
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Reduction_operators/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reduction operators
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Reduction_Even_wider_gates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reduction Even wider gates
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Combinational_for-loop_Vector_reversal_2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational for loop Vector reversal 2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Combinational_for-loop_255-bit_population_count/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational for loop 255 bit population count
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Generate_for-loop_100-bit_binary_adder_2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Generate for loop 100 bit binary adder 2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verilog_Language/Generate_for-loop_100-digit_BCD_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Generate for loop 100 digit BCD adder
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3" id="__nav_2_2_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Circuits
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3">
            <span class="md-nav__icon md-icon"></span>
            Circuits
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_1" id="__nav_2_2_2_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Combinational_Logic
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_1">
            <span class="md-nav__icon md-icon"></span>
            Combinational_Logic
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_1_1" id="__nav_2_2_2_3_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Basic_Gates
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            Basic_Gates
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Wire/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Wire
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/GND/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GND
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/NOR/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NOR
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Another_gate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Another gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Two_gates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Two gates
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/More_logic_gates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    More logic gates
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/7420_chip/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7420 chip
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Truth_tables/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Truth tables
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Two-bit_equality/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Two bit equality
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Simple_circuit_A/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple circuit A
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Simple_circuit_B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple circuit B
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Combine_circuits_A_and_B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combine circuits A and B
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Ring_or_vibrate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ring or vibrate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Thermostat/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Thermostat
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/3-bit_population_count/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3 bit population count
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Gates_and_vectors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gates and vectors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Basic_Gates/Even_longer_vectors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Even longer vectors
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_1_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_1_2" id="__nav_2_2_2_3_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Multiplexers
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_1_2">
            <span class="md-nav__icon md-icon"></span>
            Multiplexers
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Multiplexers/2-to-1_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2 to 1 multiplexer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Multiplexers/2-to-1_bus_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2 to 1 bus multiplexer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Multiplexers/9-to-1_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9 to 1 multiplexer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Multiplexers/256-to-1_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    256 to 1 multiplexer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Multiplexers/256-to-1_4-bit_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    256 to 1 4 bit multiplexer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_1_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_1_3" id="__nav_2_2_2_3_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Arithmetic_Circuits
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_1_3">
            <span class="md-nav__icon md-icon"></span>
            Arithmetic_Circuits
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/Half_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Half adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/Full_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Full adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/3-bit_binary_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3 bit binary adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/Adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/Signed_addition_overflow/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Signed addition overflow
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/100-bit_binary_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    100 bit binary adder
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Arithmetic_Circuits/4-digit_BCD_adder/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4 digit BCD adder
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_1_4" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_1_4" id="__nav_2_2_2_3_1_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Karnaugh_Map_to_Circuit
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_1_4">
            <span class="md-nav__icon md-icon"></span>
            Karnaugh_Map_to_Circuit
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/3-variable/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3-variable
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/4-variable/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-variable
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/4-variable%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-variable(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/4-variable%282%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-variable(2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/Minimum_SOP_and_POS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Minimum_SOP_and_POS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/Karnaugh_map/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Karnaugh_map
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/Karnaugh_map%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Karnaugh_map(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Combinational_Logic/Karnaugh_Map_to_Circuit/K-map_implemented_with_a_multiplexer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    K-map_implemented_with_a_multiplexer
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2" id="__nav_2_2_2_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sequential_Logic
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2">
            <span class="md-nav__icon md-icon"></span>
            Sequential_Logic
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2_1" id="__nav_2_2_2_3_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Latches_and_Flip-Flops
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2_1">
            <span class="md-nav__icon md-icon"></span>
            Latches_and_Flip-Flops
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/D_flip-flop/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    D_flip-flop
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/D_flip-flops/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    D_flip-flops
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF_with_reset/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF_with_reset
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF_with_reset_value/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF_with_reset_value
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF_with_asynchronous_reset/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF_with_asynchronous_reset
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF_with_byte_enable/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF_with_byte_enable
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/D_Latch/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    D_Latch
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF%282%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF(2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFF%2Bgate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFF+gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Mux_and_DFF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mux_and_DFF
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Mux_and_DFF%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mux_and_DFF(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/DFFs_and_gates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DFFs_and_gates
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Create_circuit_from_truth_table/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Create_circuit_from_truth_table
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Detect_an_edge/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Detect_an_edge
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Detect_both_edges/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Detect_both_edges
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Edge_capture_register/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Edge_capture_register
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Latches_and_Flip-Flops/Dual-edge_triggered_flip-flop/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dual-edge_triggered_flip-flop
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2_2" id="__nav_2_2_2_3_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Counters
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2_2">
            <span class="md-nav__icon md-icon"></span>
            Counters
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Four-bit_binary_counter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Four-bit_binary_counter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Decade_counter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Decade_counter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Decade_counter_again/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Decade_counter_again
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Slow_decade_counter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Slow_decade_counter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Counter_1-12/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Counter_1-12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/Counter_1000/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Counter_1000
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/4-digit_decimal_counter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-digit_decimal_counter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Counters/12-hour_clock/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    12-hour_clock
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2_3" id="__nav_2_2_2_3_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Shift_Registers
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2_3">
            <span class="md-nav__icon md-icon"></span>
            Shift_Registers
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/4-bit_shift_register/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-bit_shift_register
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/Left-right_rotator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Left-right_rotator
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/Left-right_arithmetic_shift/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Left-right_arithmetic_shift
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/5-bit_LFSR/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5-bit_LFSR
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/3-bit_LFSR/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3-bit_LFSR
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/32-bit_LFSR/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    32-bit_LFSR
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/Shift_register%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Shift_register(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/Shift_register%282%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Shift_register(2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Shift_Registers/3-input_LUT/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3-input_LUT
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2_4" id="__nav_2_2_2_3_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    More_Circuits
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2_4">
            <span class="md-nav__icon md-icon"></span>
            More_Circuits
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/More_Circuits/Rule_90/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rule_90
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/More_Circuits/Rule_110/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rule_110
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/More_Circuits/Conways_Game_of_Life_16x16/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Conways_Game_of_Life_16x16
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_2_5" id="__nav_2_2_2_3_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Finite_State_Machines
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="6" aria-labelledby="__nav_2_2_2_3_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_2_5">
            <span class="md-nav__icon md-icon"></span>
            Finite_State_Machines
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_1_async/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_1_async
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_1_sync/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_1_sync
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_2_async/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_2_async
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_2_sync/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_2_sync
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_state_transitions_3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_state_transitions_3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_one-hot_state_transitions_3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_one-hot_state_transitions_3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_3_async/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_3_async
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Simple_FSM_3_sync/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simple_FSM_3_sync
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Design_a_Moore_FSM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Design_a_Moore_FSM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Lemmings_1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lemmings_1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Lemmings_2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lemmings_2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Lemmings_3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lemmings_3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Lemmings_4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lemmings_4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/One-hot_FSM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    One-hot_FSM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/PS2_packet_parser/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PS2_packet_parser
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/PS2_packet_parser_and_datapath/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PS2_packet_parser_and_datapath
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Serial_receiver/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Serial_receiver
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Serial_receiver_and_datapath/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Serial_receiver_and_datapath
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Serial_receiver_with_parity_checking/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Serial_receiver_with_parity_checking
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Sequence_recognition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sequence_recognition
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Design_a_Mealy_FSM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Design_a_Mealy_FSM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Serial_twos_complementer_Moore/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Serial_twos_complementer_Moore
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Serial_twos_complementer_Mealy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Serial_twos_complementer_Mealy
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM%282%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM(2)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM_logic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM_next-state_logic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_next-state_logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM_one-hot_next-state_logic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_one-hot_next-state_logic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM%283%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM(3)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM%284%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM(4)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/One-hot_FSM_equations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    One-hot_FSM_equations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/FSM%285%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM(5)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Sequential_Logic/Finite_State_Machines/Another_FSM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Another_FSM
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_3_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_3_3" id="__nav_2_2_2_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Building_Larger_Circuits
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_2_2_2_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_3_3">
            <span class="md-nav__icon md-icon"></span>
            Building_Larger_Circuits
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/Counter_with_period_1000/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Counter_with_period_1000
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/4-bit_shift_register_and_down_counter/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4-bit_shift_register_and_down_counter
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/FSM_Sequence_1101_recognizer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_Sequence_1101_recognizer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/FSM_Enable_shift_register/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_Enable_shift_register
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/FSM_The_complete_FSM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_The_complete_FSM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/The_complete_timer/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The_complete_timer
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Circuits/Building_Larger_Circuits/FSM_One-hot_logic_equations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FSM_One-hot_logic_equations
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_4" id="__nav_2_2_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Verification_Reading Simulations
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_4">
            <span class="md-nav__icon md-icon"></span>
            Verification_Reading Simulations
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Finding_bugs_in_code/Mux/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mux
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Finding_bugs_in_code/NAND/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NAND
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Finding_bugs_in_code/Mux%281%29/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mux(1)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Finding_bugs_in_code/Add_sub/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Add_sub
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Finding_bugs_in_code/Case_statement/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Case_statement
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Combinational_circuit6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Combinational_circuit6
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Sequential_circuit7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sequential_circuit7
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Sequential_circuit8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sequential_circuit8
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Sequential_circuit9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sequential_circuit9
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Reading%20Simulations/Build_a_circuit_from_a_simulation_waveform/Sequential_circuit10/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sequential_circuit10
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_5" id="__nav_2_2_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Verification:Writing Testbenches
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_5">
            <span class="md-nav__icon md-icon"></span>
            Verification:Writing Testbenches
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Writing_Testbenches/AND_gate/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AND gate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Writing_Testbenches/Clock/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Clock
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Writing_Testbenches/T_flip-flop/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T flip flop
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Writing_Testbenches/Testbench1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Testbench1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../HDLBits/Verification_Writing_Testbenches/Testbench2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Testbench2
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_6" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../.." class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Cs450
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_6">
            <span class="md-nav__icon md-icon"></span>
            Cs450
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    原理图&PCB设计
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            原理图&PCB设计
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    基础知识
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            基础知识
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    元器件
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            元器件
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8E%9F%E7%90%86%E5%9B%BE%26PCB%E8%AE%BE%E8%AE%A1/%E7%94%B5%E9%98%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    电阻
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 千兆以太网
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. 千兆以太网">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 以太网基础知识
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1 以太网基础知识">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-phy" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.1 PHY芯片介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.1 PHY芯片介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 功能
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 工作原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 技术规格
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 应用场景
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5. 选型要点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-osi" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.2 OSI七层模型介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.2 OSI七层模型介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#osi" class="md-nav__link">
    <span class="md-ellipsis">
      OSI七层模型功能协议对照表
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-gmiirgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.3 GMII和RGMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.1.3 GMII和RGMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gmii" class="md-nav__link">
    <span class="md-ellipsis">
      GMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      主要特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      应用场景
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      RGMII接口介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RGMII接口介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      主要特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      应用场景
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gmii-vs-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      GMII vs RGMII
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      说明：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rgmii_1" class="md-nav__link">
    <span class="md-ellipsis">
      RGMII接口时序设计
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      数据包结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#udpicmptcparp" class="md-nav__link">
    <span class="md-ellipsis">
      UDP、ICMP、TCP和ARP之间的关系
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114-udpip" class="md-nav__link">
    <span class="md-ellipsis">
      1.1.4 UDP首部校验和、IP首部校验和计算方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 项目框架和时序图绘制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-rgmiirgmii_recivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.3 RGMII接收模块代码编写：rgmii_recive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.3 RGMII接收模块代码编写：rgmii_recive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-ibuf" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.2 IBUF（输入缓冲器）原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133-bufgbufioio" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.3 BUFG（全局时钟缓冲器）、BUFIO（I/O时钟缓冲器）原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134-idelay" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.4 IDELAY原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#135-iddr" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.5 IDDR原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.6 RGMII接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#137" class="md-nav__link">
    <span class="md-ellipsis">
      1.3.7 代码仿真代码与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-rgmiirgmii_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.4 RGMII发送模块代码编写：rgmii_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.4 RGMII发送模块代码编写：rgmii_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142-oddr" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.2 ODDR原语的作用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143-rgmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.3 RGMII发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#144" class="md-nav__link">
    <span class="md-ellipsis">
      1.4.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.5 UDP协议栈架构设计及时钟规划
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#16-macmac_receivevv" class="md-nav__link">
    <span class="md-ellipsis">
      1.6 MAC接收模块代码编写：mac_receivev.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6 MAC接收模块代码编写：mac_receivev.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#161" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.1 模块设计思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#162" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2 状态机逻辑讲解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6.2 状态机逻辑讲解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1621verilog" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.1状态机的Verilog实现步骤
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.6.2.1状态机的Verilog实现步骤">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      （1）状态定义
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      （2）状态寄存器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      （3）下一状态逻辑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      （4）输出逻辑
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1622-1" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.2 应用案例1：自动贩卖机示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1623-2" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.2.3 应用案例2：交通信号灯示例
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#163-fifofifo" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.3 深入理解FIFO的底层资源（设置FIFO的位宽和深度即类型）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#164-gmii" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.4 GMII输入信号延迟处理逻辑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#165-sfdmaccrc" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.5 校验逻辑实现（前导码、SFD、MAC地址、crc数据校验内容）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#166-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.6 以太网数据帧分离（剥离有效数据和mac包头)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#167-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.7 MAC层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#168-mac_to_arp_ipv" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.8 mac_to_arp_ip.v模块编写
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#168" class="md-nav__link">
    <span class="md-ellipsis">
      1.6.8 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#17-macmac_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.7 MAC发送模块代码编写：mac_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.7 MAC发送模块代码编写：mac_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.1 添加MAC头部
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#172" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.2 跨时钟域处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#173-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3 CRC校验(循环冗余校验)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.7.3 CRC校验(循环冗余校验)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1731-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.1 什么是 CRC？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1732-crc" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.2 CRC 计算原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1733" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.3模块代码解析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1734" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.4完整计算流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1735" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.5 总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1736" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.6 实际使用时的便捷方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1737" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.7 模块代码解析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1738" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.8 完整代码工程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1739" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.9 代码仿真与验证
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#17310" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.3.10 关键问题回答
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#174-mac" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.4 MAC层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#175" class="md-nav__link">
    <span class="md-ellipsis">
      1.7.5 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#18-ipip_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.8 IP接收模块代码编写：ip_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.8 IP接收模块代码编写：ip_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#181" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.1 模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#182" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.2核心功能实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#183-ip" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.3 IP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#184" class="md-nav__link">
    <span class="md-ellipsis">
      1.8.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#19-ipip_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.9 IP发送模块代码编写：ip_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.9 IP发送模块代码编写：ip_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#191" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.1 模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#192" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.2 核心代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#193-ip" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.3 IP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#194" class="md-nav__link">
    <span class="md-ellipsis">
      1.9.4 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#110-udpudp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.10 UDP接收模块代码编写：udp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.10 UDP接收模块代码编写：udp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1101-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.1 UDP接收模块功能简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1102-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.2 UDP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1103" class="md-nav__link">
    <span class="md-ellipsis">
      1.10.3 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#111-udpudp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.11 UDP发送模块代码编写：udp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.11 UDP发送模块代码编写：udp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1111-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.1 UDP发送模块简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1112-udp" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.2 UDP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1113" class="md-nav__link">
    <span class="md-ellipsis">
      1.11.3 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.12 ARP介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-arparp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.13 ARP接收模块代码编写：arp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.13 ARP接收模块代码编写：arp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1131-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.13.1 ARP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1132" class="md-nav__link">
    <span class="md-ellipsis">
      1.13.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#114-arparp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.14 ARP发送模块代码编写：arp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.14 ARP发送模块代码编写：arp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1141-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.14.1 ARP层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1142" class="md-nav__link">
    <span class="md-ellipsis">
      1.14.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#115-arparp_dynamic_listv" class="md-nav__link">
    <span class="md-ellipsis">
      1.15 ARP动态列表模块编写arp_dynamic_list.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.15 ARP动态列表模块编写arp_dynamic_list.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1151-arp" class="md-nav__link">
    <span class="md-ellipsis">
      1.15.1 ARP动态列表代码
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#116-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16 ICMP协议介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.16 ICMP协议介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1161-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16.1 ICMP协议分类
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1162-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.16.2. ICMP数据包的结构与实现流程
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#117-icmpicmp_receivev" class="md-nav__link">
    <span class="md-ellipsis">
      1.17 ICMP接收模块代码编写：icmp_receive.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.17 ICMP接收模块代码编写：icmp_receive.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1171-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.17.1 ICMP层接收模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1172" class="md-nav__link">
    <span class="md-ellipsis">
      1.17.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#118-icmpicmp_sendv" class="md-nav__link">
    <span class="md-ellipsis">
      1.18 ICMP发送模块代码编写：icmp_send.v
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1.18 ICMP发送模块代码编写：icmp_send.v">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1181-icmp" class="md-nav__link">
    <span class="md-ellipsis">
      1.18.1 ICMP层发送模块代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1182" class="md-nav__link">
    <span class="md-ellipsis">
      1.18.2 代码仿真与验证
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/fpga/以太网通信.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  


<h1 id="_1">千兆以太网通信</h1>
<p>千兆以太网通信笔记，包含内容较多，包括以太网基础知识、Wireshark抓包抓取绑定MAC地址、RGMII接收模块、RGMII发送模块、UDP协议栈架构编写、MAC接收模块、MAC发送模块、CRC校验模块、MAC顶层以及实例化CRC校验模块、mac to arp ip模块代码、ip接收与发送模块代码、UDP接收与发送模块代码、UDP回环实验仿真以及上班验证、Wireshark抓取arp数据包、arp协议层代码设计、ICMP协议层代码设计以及时序约束-跨时钟域约束、</p>
<p>然后通过使用以太网在LCD屏幕显示主机屏幕画面和ADC采集存储系统两个项目实验作为本节的结束（包括介绍VGA显示模块和ADC采集存储模块）。</p>
<p>后续会添加使用AXI4_DDR3对数据进行缓存处理，图像进行乒乓操作防止画面撕裂，以及图像处理和数字信号处理相关的内容。这是一个较大的工程项目。</p>
<p>祝愿本次项目我能够坚持下去并顺利完结，通过更新笔记内容对自己进行督促。</p>
<h2 id="1">1. 千兆以太网</h2>
<h3 id="11">1.1 以太网基础知识</h3>
<p>使用FPGA与主机通过以太网交互信息在工业上是一种非常常用的手段，得益于基于FPGA的以太网传输系统可以实现微秒级的延时，满足工业自动化中快速反馈和精确控制的需求，FPGA通过RJ45网口（我们主机和FPGA上插入网线的元件）与板载的PHY芯片（网络通信设备中的核心组件）与我们主机的RJ45和PHY芯片进行传输信息，在这期间涉及到组包和解包（OSI七层模型）的过程，</p>
<h4 id="111-phy">1.1.1 PHY芯片介绍</h4>
<p>PHY芯片（Physical Layer Chip）是网络通信设备中的核心组件，用于实现OSI模型中物理层的功能，主要负责数据信号在物理介质（如双绞线、光纤等）上的传输和接收。以下是关于PHY芯片的详细介绍：</p>
<h5 id="1_1">1. <strong>功能</strong></h5>
<ul>
<li><strong>信号转换</strong>：将数字信号转换为适合在物理介质上传输的模拟信号，并在接收端将模拟信号还原为数字信号。</li>
<li><strong>自动协商</strong>：支持自动协商功能，能够根据对端设备自动调整传输速率（如10Mbps、100Mbps、1Gbps等）和工作模式。</li>
<li><strong>时钟提取</strong>：从接收到的数据中提取时钟信号，以同步发送和接收。</li>
<li><strong>差分信号传输</strong>：支持差分信号传输，减少干扰和误码率。</li>
<li><strong>故障诊断</strong>：支持故障诊断和报告功能，帮助快速定位网络问题。</li>
<li><strong>节能功能</strong>：提供低功耗模式，降低设备能耗。</li>
</ul>
<h5 id="2">2. <strong>工作原理</strong></h5>
<p>PHY芯片的工作流程主要包括：</p>
<ol>
<li>将来自MAC层的并行数据转换为串行数据。</li>
<li>对数据进行编码（如4B/5B编码）并调制为模拟信号发送出去。</li>
<li>在接收端，将模拟信号解调为数字信号，解码后恢复为原始数据。</li>
</ol>
<h5 id="3">3. <strong>技术规格</strong></h5>
<ul>
<li><strong>传输速率</strong>：支持多种速率，包括10Mbps、100Mbps、1Gbps、2.5Gbps、5Gbps和10Gbps。</li>
<li><strong>接口类型</strong>：支持MII、RMII、GMII等接口，用于与MAC层通信。</li>
<li><strong>传输介质</strong>：支持双绞线、光纤等多种物理介质。</li>
<li><strong>低功耗设计</strong>：采用先进的低功耗架构，适合对功耗敏感的应用场景。</li>
</ul>
<h5 id="4">4. <strong>应用场景</strong></h5>
<p>PHY芯片广泛应用于以下领域：</p>
<ul>
<li><strong>数据中心网络</strong>：用于服务器、交换机和路由器之间的高速数据传输。</li>
<li><strong>企业局域网</strong>：连接计算机、打印机、IP电话等设备。</li>
<li><strong>家庭网络</strong>：支持家庭路由器和交换机。</li>
<li><strong>工业控制网络</strong>：用于传感器、执行器和控制器之间的通信。</li>
<li><strong>汽车电子</strong>：支持车载以太网，如辅助驾驶和液晶仪表盘。</li>
</ul>
<h5 id="5">5. <strong>选型要点</strong></h5>
<ul>
<li><strong>速率支持</strong>：根据应用需求选择支持特定速率的PHY芯片。</li>
<li><strong>功耗</strong>：优先选择低功耗设计的芯片。</li>
<li><strong>兼容性</strong>：确保PHY芯片与MAC层及其他网络设备兼容。</li>
<li><strong>可靠性</strong>：考虑芯片的抗干扰能力和稳定性。</li>
</ul>
<p>总之，PHY芯片在网络通信中扮演着不可或缺的角色，其性能和功能直接影响网络的稳定性和传输效率</p>
<h4 id="112-osi">1.1.2 OSI七层模型介绍</h4>
<p>以下图片解释了OSI七层模型的内容，在我们FPGA中只需要关注1，2，3，4层内容即可，即物理层、数据链路层、网络层和传输层。</p>
<h5 id="osi">OSI七层模型功能协议对照表</h5>
<table>
<thead>
<tr>
<th style="text-align: left;">OSI层</th>
<th style="text-align: center;">功能</th>
<th>TCP/IP协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">应用层（Application layer）</td>
<td style="text-align: center;">文件传输、电子邮件、文件服务、虚拟终端</td>
<td>TFTP/HTTP/SNMP/FTP/SMTP/DNS/Telnet</td>
</tr>
<tr>
<td style="text-align: left;">表示层（Presentation layer）</td>
<td style="text-align: center;">数据格式化、代码转换、数据加密</td>
<td>DECnet NSP/LPP/XDP/IPX</td>
</tr>
<tr>
<td style="text-align: left;">会话层（Session layer）</td>
<td style="text-align: center;">解除或建立与其他接点的联系</td>
<td>SSL/TLS/DAP/RPC/</td>
</tr>
<tr>
<td style="text-align: left;">传输层（Transport layer）</td>
<td style="text-align: center;">提供端对端的接口</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td style="text-align: left;">网络层（Network layer）</td>
<td style="text-align: center;">为数据包选择路由，控制子网运行，逻辑编址</td>
<td>IP/ICMP/RIP/OSPF/BGP/IGMP</td>
</tr>
<tr>
<td style="text-align: left;">数据链路层（Data link layer）</td>
<td style="text-align: center;">物理寻址，传输有地址的帧，错误检测功能</td>
<td>以太网、网卡、交换机、PPTP、ARP、ATMP等</td>
</tr>
<tr>
<td style="text-align: left;">物理层（Physical layer）</td>
<td style="text-align: center;">以二进制比特流数据形式在物理媒体上传输数据，机械电子接口</td>
<td>IEEE802/Ethernet v.2</td>
</tr>
</tbody>
</table>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121013855.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白FPGA讲义" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121013855.png" /></a></p>
<p>传输方式，即通过用户数据，通过传输层后加入UDP头部，再通过网络层加入IP头部，然后通过数据链路层加入MAC头部，最后进入物理层将数据生成对应的比特流输出给主机。具体传输方式如下</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121014501.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白FPGA讲义" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121014501.png" /></a></p>
<h4 id="113-gmiirgmii">1.1.3 GMII和RGMII接口介绍</h4>
<h5 id="gmii">GMII接口介绍</h5>
<p>GMII（Gigabit Media Independent Interface，千兆媒体独立接口）是一种用于千兆以太网（1000Mbps）的接口标准，用于连接MAC（媒体访问控制）层和PHY（物理层）芯片。</p>
<h6 id="_2">主要特点</h6>
<ol>
<li><strong>数据速率</strong>：支持1000Mbps的传输速率。</li>
<li><strong>数据位宽</strong>：8位数据通道，工作时钟频率为125MHz。</li>
<li><strong>信号线数量</strong>：共24根信号线，包括发送和接收数据线、控制信号线、时钟信号线和管理接口信号线。</li>
<li><strong>兼容性</strong>：向下兼容10Mbps和100Mbps速率。</li>
<li><strong>全双工操作</strong>：支持全双工通信。</li>
<li><strong>管理接口</strong>：提供MDC（管理总线时钟）和MDIO（管理总线数据）信号，用于设备管理和配置。</li>
</ol>
<h6 id="_3">应用场景</h6>
<p>GMII接口主要用于千兆以太网设备，如交换机、路由器和网络接口卡，适用于对带宽要求较高的场景。</p>
<h5 id="rgmii">RGMII接口介绍</h5>
<p>RGMII（Reduced Gigabit Media Independent Interface，精简千兆媒体独立接口）是GMII接口的简化版本，旨在减少引脚数量和降低功耗。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121015348.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="英特尔官网" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121015348.png" /></a></p>
<h6 id="_4">主要特点</h6>
<ol>
<li><strong>数据速率</strong>：支持10Mbps、100Mbps和1000Mbps的自适应速率。</li>
<li><strong>数据位宽</strong>：4位数据通道，通过双倍数据速率（DDR）技术在<strong>时钟上升沿和下降沿传输数据</strong>。</li>
<li><strong>信号线数量</strong>：仅需12根信号线。</li>
<li><strong>时钟频率</strong>：</li>
<li>1000Mbps：125MHz。</li>
<li>100Mbps：25MHz。</li>
<li>10Mbps：2.5MHz。</li>
<li><strong>信号复用</strong>：将TX_ER和TX_EN复用为TX_CTL，RX_ER和RX_DV复用为RX_CTL。</li>
<li><strong>全双工操作</strong>：支持全双工通信。</li>
<li><strong>管理接口</strong>：同样支持MDC和MDIO信号。</li>
</ol>
<h6 id="_5">应用场景</h6>
<p>RGMII接口广泛应用于对成本和功耗敏感的场景，如嵌入式设备、FPGA板卡和小型网络设备。</p>
<h6 id="gmii-vs-rgmii">GMII vs RGMII</h6>
<table>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">MII</th>
<th style="text-align: left;">RMII</th>
<th style="text-align: left;">GMII</th>
<th style="text-align: left;">RGMII</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>数据速率</strong></td>
<td style="text-align: left;">10/100 Mbps</td>
<td style="text-align: left;">10/100 Mbps</td>
<td style="text-align: left;">10/100/1000 Mbps</td>
<td style="text-align: left;">10/100/1000 Mbps</td>
</tr>
<tr>
<td style="text-align: left;"><strong>数据位宽</strong></td>
<td style="text-align: left;">4位</td>
<td style="text-align: left;">2位</td>
<td style="text-align: left;">8位</td>
<td style="text-align: left;">4位</td>
</tr>
<tr>
<td style="text-align: left;"><strong>信号线数量</strong></td>
<td style="text-align: left;">16根</td>
<td style="text-align: left;">7根</td>
<td style="text-align: left;">24根</td>
<td style="text-align: left;">12根</td>
</tr>
<tr>
<td style="text-align: left;"><strong>时钟频率</strong></td>
<td style="text-align: left;">25MHz（100Mbps）<br>2.5MHz（10Mbps）</td>
<td style="text-align: left;">50MHz（100Mbps）<br>2.5MHz（10Mbps）</td>
<td style="text-align: left;">125MHz（1000Mbps）<br>25MHz（100Mbps）<br>2.5MHz（10Mbps）</td>
<td style="text-align: left;">125MHz（1000Mbps，DDR）<br>25MHz（100Mbps）<br>2.5MHz（10Mbps）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>传输模式</strong></td>
<td style="text-align: left;">单数据速率（SDR）</td>
<td style="text-align: left;">单数据速率（SDR）</td>
<td style="text-align: left;">单数据速率（SDR）</td>
<td style="text-align: left;">双数据速率（DDR，1000Mbps）<br>单数据速率（SDR，10/100Mbps）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>功耗</strong></td>
<td style="text-align: left;">较高</td>
<td style="text-align: left;">较低</td>
<td style="text-align: left;">高</td>
<td style="text-align: left;">较低</td>
</tr>
<tr>
<td style="text-align: left;"><strong>应用场景</strong></td>
<td style="text-align: left;">早期以太网设备，成本敏感</td>
<td style="text-align: left;">成本敏感、低功耗设备</td>
<td style="text-align: left;">高带宽需求设备</td>
<td style="text-align: left;">成本敏感、低功耗且支持千兆以太网</td>
</tr>
<tr>
<td style="text-align: left;"><strong>特点</strong></td>
<td style="text-align: left;">信号线多，适合低速以太网</td>
<td style="text-align: left;">信号线少，简化设计</td>
<td style="text-align: left;">支持千兆以太网，兼容低速模式</td>
<td style="text-align: left;">信号线少，支持千兆以太网，低功耗</td>
</tr>
</tbody>
</table>
<p>RGMII通过减少信号线数量和采用DDR技术，在保持高传输速率的同时降低了功耗和PCB布局的复杂性，注意，再RGMII和GMII接口模块图中，TXD和RXD一个是4为并行数据位宽（支持时钟上升沿和下降沿双边采样）一个是8位并行数据位宽（只支持时钟上升沿采样）</p>
<p>关于更多信息请参考：<a href="https://www.intel.cn/content/www/cn/zh/docs/programmable/683634/20-4/rmii-and-rgmii-phy-interfaces.html">英特尔：5.1.7.1.2. RMII和RGMII PHY接口</a></p>
<p>以下举例说明RGMII接口的信号定义及其详细备注信息（MAC可以理解为FPGA板卡，PHY芯片可以理解为FPGA板载的PHY芯片，从MAC -&gt; PHY则是FPGA输出给FPGA板载的PHY芯片）：</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>信号名称</strong></th>
<th style="text-align: left;"><strong>方向</strong></th>
<th style="text-align: left;"><strong>备注信息</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>TX_CLK</strong></td>
<td style="text-align: left;">MAC → PHY</td>
<td style="text-align: left;">发送时钟信号，由MAC提供。在1000Mbps模式下为125MHz，100Mbps模式下为25MHz，10Mbps模式下为2.5MHz。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TX_CTL</strong></td>
<td style="text-align: left;">MAC → PHY</td>
<td style="text-align: left;">发送控制信号，用于传输数据有效（TXEN）和数据错误（TXERR）信息。在时钟上升沿表示TXEN，下降沿表示TXERR。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>TXD3:0</strong></td>
<td style="text-align: left;">MAC → PHY</td>
<td style="text-align: left;">发送数据信号，4位宽。在1000Mbps模式下，每个时钟周期内传输8位数据（DDR模式），上升沿传输TXD3:0，下降沿传输TXD7:4，数据位宽为4位。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>RX_CLK</strong></td>
<td style="text-align: left;">PHY → MAC</td>
<td style="text-align: left;">接收时钟信号，由PHY提供。在1000Mbps模式下为125MHz，100Mbps模式下为25MHz，10Mbps模式下为2.5MHz。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>RX_CTL</strong></td>
<td style="text-align: left;">PHY → MAC</td>
<td style="text-align: left;">接收控制信号，用于接收数据有效（RXDV）和数据错误（RXERR）信息。在时钟上升沿表示RXDV，下降沿表示RXERR。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>RXD3:0</strong></td>
<td style="text-align: left;">PHY → MAC</td>
<td style="text-align: left;">接收数据信号，4位宽。在1000Mbps模式下，每个时钟周期内传输8位数据（DDR模式），上升沿传输RXD3:0，下降沿传输RXD7:4，数据位宽为4位。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MDC</strong></td>
<td style="text-align: left;">MAC → PHY</td>
<td style="text-align: left;">管理总线时钟信号，用于设备管理和配置。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>MDIO</strong></td>
<td style="text-align: left;">双向</td>
<td style="text-align: left;">管理总线数据信号，用于设备管理和配置，支持双向通信。</td>
</tr>
</tbody>
</table>
<h6 id="_6">说明：</h6>
<ol>
<li><strong>DDR模式</strong>：在1000Mbps模式下，TXD和RXD信号使用双倍数据速率（DDR）技术，在时钟的上升沿和下降沿分别传输数据。</li>
<li><strong>SDR模式</strong>：在10Mbps和100Mbps模式下，TXD和RXD信号使用单数据速率（SDR）技术，仅在时钟上升沿传输数据。</li>
<li><strong>信号电平</strong>：通常为1.8V、2.5V或3.3V，具体取决于硬件设计。</li>
<li><strong>时钟偏斜</strong>：为确保时序正确，TX_CLK和RX_CLK需要满足一定的时钟偏斜要求。</li>
</ol>
<h5 id="rgmii_1">RGMII接口时序设计</h5>
<p>RGMII的时序分为两种：延时模式和非延时模式，可以通过配置PHY芯片改变模式。用的比较多的模式是延时模式，一般PHY芯片默认配置为延时模式。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095130.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白FPGA" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095130.png" /></a></p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095256.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白FPGA" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095256.png" /></a></p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095319.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白fpga" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095319.png" /></a></p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095344.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白fpga" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095344.png" /></a></p>
<h5 id="_7">数据包结构</h5>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095922.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121095922.png" /></a></p>
<table>
<thead>
<tr>
<th>MAC数据包</th>
<th>字节大小</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>前导码</td>
<td>7byte</td>
<td>8‘h55（固定值）</td>
</tr>
<tr>
<td>SFD</td>
<td>1byte</td>
<td>8'hd5（固定值）</td>
</tr>
<tr>
<td>目的mac地址</td>
<td>6byte</td>
<td></td>
</tr>
<tr>
<td>源mac地址</td>
<td>6byte</td>
<td></td>
</tr>
<tr>
<td>类型/长度</td>
<td>2byte</td>
<td>小于1536表示长度，大于1536表示类型，arp:16'h0006，ip：16’h0800</td>
</tr>
<tr>
<td>MAC层数据</td>
<td>46byte-1500byte</td>
<td>mac有效数据</td>
</tr>
<tr>
<td>FCS</td>
<td>48byte</td>
<td>CRC校验</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>IP头部</th>
<th>字节大小</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本+首部长度</td>
<td>1byte</td>
<td>版本ipv4：4‘h4，首部长度：4’h5</td>
</tr>
<tr>
<td>服务类型</td>
<td>1byte</td>
<td>一般为8‘h0</td>
</tr>
<tr>
<td>总长度</td>
<td>2byte</td>
<td>ip首部长度+ip层数据长度</td>
</tr>
<tr>
<td>标识</td>
<td>2byte</td>
<td>复位给0，发送一包数据自加1</td>
</tr>
<tr>
<td>标记+分段偏移2byte</td>
<td>2byte</td>
<td>标记：3bit。最高位保留位0；中间位为是否开启分段，0不开启，1开启；最低为表示是否存在下一个分段，0表示为最后一个分段，1表示还存在下一个分段，一般默认为3’b010</td>
</tr>
<tr>
<td>生存时间</td>
<td>1byte</td>
<td>表示以太网数据包可以中转进过多少路由器，每次进入一个路由器后，该值会减少1，直到减少到0就会丢包，win系统默认为8'h80</td>
</tr>
<tr>
<td>协议</td>
<td>1byte</td>
<td>udp:8'd17, tcp:8'd6, icmp:8'd1</td>
</tr>
<tr>
<td>首部校验和</td>
<td>1byte</td>
<td></td>
</tr>
<tr>
<td>源ip地址</td>
<td>4byte</td>
<td></td>
</tr>
<tr>
<td>目的ip地址</td>
<td>4byte</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>UDP头部</th>
<th>字节大小</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>源端口号</td>
<td>2byte</td>
<td></td>
</tr>
<tr>
<td>目的端口号</td>
<td>2byte</td>
<td></td>
</tr>
<tr>
<td>udp长度</td>
<td>固定8byte+udp数据包长度</td>
<td></td>
</tr>
<tr>
<td>udp校验和</td>
<td>2byte</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="udpicmptcparp">UDP、ICMP、TCP和ARP之间的关系</h5>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121104936.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白fpga" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121104936.png" /></a></p>
<h4 id="114-udpip">1.1.4 UDP首部校验和、IP首部校验和计算方法</h4>
<p>udp和ip首部校验的计算方法是一模一样的，如下图所示</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121105404.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250121105404.png" /></a> </p>
<h3 id="12">1.2 项目框架和时序图绘制</h3>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig%E6%A1%86%E5%9B%BE.drawio.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig%E6%A1%86%E5%9B%BE.drawio.png" /></a></p>
<p>因为内容较多，图文讲解不易懂，所以请参考教程视频进行学习巩固。</p>
<h3 id="13-rgmiirgmii_recivev">1.3 RGMII接收模块代码编写：rgmii_recive.v</h3>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250210113230.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250210113230.png" /></a></p>
<h4 id="131">1.3.1 模块设计思路</h4>
<p>在这个设计中，我们通过对接收到的信号进行多层缓冲、延迟控制以及 <strong>IDDR</strong> 原语将双边沿信号（rgmii）转换成单边沿信号（gmii），以便后续处理。具体操作如下:</p>
<p>首先，我们将<code>phy_rgmii_rx_clk</code> ,<code>phy_regmii_rx_ctl</code>,<code>phy_rgmii_rx_data</code>输入的信号经过<code>IBUF (输入缓冲器)</code>，提高信号质量，避免信号在传输过程中的抖动和噪声。输出得到<code>phy_rgmii_rx_clk_ibuf</code> ,<code>phy_regmii_rx_ctl_ibuf</code>,<code>phy_rgmii_rx_data_ibuf</code>信号</p>
<p>接下来，将我们得到的<code>phy_rgmii_rx_clk_ibuf</code> 信号分别经过<code>BUFIO(I/O时钟缓冲器)</code>和<code>BUFG（全局时钟缓冲器）</code>分别得到<code>phy_rgmii_rx_clk_ibuf_bufio</code>和<code>gmii_rx_clk</code>，其中<code>phy_rgmii_rx_clk_ibuf_bufio</code>时钟信号线等待下一步处理，<code>gmii_rx_clk</code>则作为<code>gmii</code>作为时钟信号</p>
<p><code>IDELAYE2</code> 原语用于输入信号的延迟控制，常用于高频信号的接收和处理。在该模块中，<code>IDELAYE2</code> 原语用于延迟接收到的 <code>phy_rgmii_rx_ctl</code> 和 <code>phy_rgmii_rx_data</code> 信号，以减少信号的时序误差。具体来说，<code>IDELAYE2</code> 被用来对 <code>phy_rgmii_rx_ctl_ibuf</code> 和 <code>phy_rgmii_rx_data_ibuf</code> 进行延迟处理，确保数据和时钟信号的同步性，消除由于信号传输延迟或时钟偏差带来的问题。此处信号的输出命名为<code>`phy_rgmii_rx_ctl_ibuf_delay</code>和<code>phy_rgmii_rx_data_ibuf_delay</code></p>
<p>最后，确保接收到的信号足够稳定之后，将双边沿采样的RGMII数据通过<code>IDDR(输入双倍速率触发器)</code>转换成单边沿信号。在此设计中，<code>IDDR</code> 用于将经过延迟后的数据 (<code>phy_rgmii_rx_ctl_ibuf_delay</code> 和 <code>phy_rgmii_rx_data_ibuf_delay</code>) 在每个时钟周期的上升沿和下降沿分别采样，输出 <code>gmii_rx_data_vld</code>、<code>gmii_rx_data_error</code> 和 <code>gmii_rx_data</code> 信号。</p>
<p>下面给大家整理了这个模块中用到的原语的详细讲解文字，如果上面的内容存在疑惑，可以针对性的查阅下面的原语介绍的内容。</p>
<h4 id="132-ibuf">1.3.2 IBUF（输入缓冲器）原语的作用</h4>
<p>IBUF可以想象成为一个“信号安检门”，主要作用是将外部信号“整理一下”，再“安全的”送进FPGA内部，总之，IBUF的作用就是让外部信号“安全、干净、整齐”的进入FPGA，为后续的处理做好准备，具体来说有一下几个作用：</p>
<ol>
<li>信号“整形”：外部信号因为传输距离长或者干扰，变得“歪歪扭扭”，IBUF就像一个美颜相机一样，吧信号“修整”成整齐、清晰的样子，让FPGA内部的逻辑电路更好的识别。</li>
<li>“保护门“：外部信号可能带有”杂质“（比如电压波动、噪声等），IBUF就像一个”过滤器“一样，将这些”杂质“过滤掉，只让干净的信号进入FPGA内部，保护内部电路不受损坏。</li>
<li>”信号放大器“：有时候我们的外部信号比较弱，IBUF可以把它”放大“一下，让它有足够的力量驱动FPGA内部的电路。</li>
<li>”信号隔离带“：IBUF就像一个“隔离带”，把外部信号和FPGA内部电路进行隔开，防止外部的“动荡”（比如电压波动）影响到内部的正常工作。</li>
</ol>
<p>在FPGA设计中，IBUF通常可以由综合工具自动插入，与顶层的输入端口或者输入输出端口进行直接相连接，如果需要手动实例化IBUF，可以使用下面的方法：</p>
<ol>
<li>首先在vivado中打开“Language Temlates”，搜索”ibuf“</li>
</ol>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125195316.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125195316.png" /></a></p>
<ol>
<li>在下面菜单中找到与自己板卡一致以及实际项目需要的选项，直接在我们的rtl程序中粘贴进去即可。不管是K7还是A7开发板，这个原语都是这样的，这里给出我们当前的示例：</li>
</ol>
<pre><code class="language-verilog">// 单个端口通过IBUF
IBUF #(
      .IBUF_LOW_PWR(&quot;TRUE&quot;),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      .IOSTANDARD(&quot;DEFAULT&quot;)  // Specify the input I/O standard
   ) IBUF_inst (
      .O(O),     // Buffer output
      .I(I)      // Buffer input (connect directly to top-level port)
   );

// 多条数据线路通过IBUF写法：genvar,generate
genvar i_rx;//genvar是一种特殊的整型变量，用于在generate块中定义循环变量,只能在generate块中使用，不能在其他地方使用
generate 
    for(i_rx = 0; i_rx &lt; 4; i_rx++) begin
        IBUF #(
          .IBUF_LOW_PWR(&quot;TRUE&quot;),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
          .IOSTANDARD(&quot;DEFAULT&quot;)  // Specify the input I/O standard
       ) IBUF_inst (
          .O(O),     // Buffer output
          .I(I)      // Buffer input (connect directly to top-level port)
       );    
    end
endgenerate


</code></pre>
<h4 id="133-bufgbufioio">1.3.3 BUFG（全局时钟缓冲器）、BUFIO（I/O时钟缓冲器）原语的作用</h4>
<p><code>BUFG</code>和<code>BUFIO</code>是两种常用的时钟缓冲原语，它们在FPGA设计中具有重要作用，主要用于优化时钟信号的传输和分配</p>
<p><code>BUFG</code>是一种全局时钟缓冲器，用于将时钟信号分配到FPGA内部的全局时钟网络。它具有以下特点：</p>
<ul>
<li><strong>低延迟和低抖动</strong>：<code>BUFG</code>的输出到达FPGA内部的I/O块（IOB）、逻辑块（CLB）、块RAM等的时钟延迟和抖动最小。</li>
<li><strong>高驱动能力</strong>：能够驱动整个FPGA芯片内的任何时钟点。</li>
<li><strong>应用场景</strong>：适用于需要全局分配的时钟信号，例如系统时钟。</li>
</ul>
<pre><code class="language-verilog">   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output.
      .I(I)  // 1-bit input: Clock input.
   );
</code></pre>
<p><code>BUFIO</code>是用于I/O时钟网络的缓冲器，具有以下特点：</p>
<ul>
<li><strong>独立于全局时钟资源</strong>：<code>BUFIO</code>的时钟网络独立于全局时钟资源，适合采集源同步数据。</li>
<li><strong>低延时</strong>：在采集源同步I/O数据时，<code>BUFIO</code>可以提供非常小的延时，适合用于高速I/O接口。</li>
<li><strong>驱动范围限制</strong>：<code>BUFIO</code>只能驱动同一时钟区域内的I/O块逻辑，不能驱动FPGA内部的逻辑块（CLB）。</li>
</ul>
<pre><code class="language-verilog">   BUFIO BUFIO_inst (
      .O(O), // 1-bit output: Clock output (connect to I/O clock loads).
      .I(I)  // 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );
</code></pre>
<p>使用建议：</p>
<ul>
<li><strong>全局时钟分配</strong>：如果需要将时钟信号分配到整个FPGA芯片的逻辑资源，建议使用<code>BUFG</code>。</li>
<li><strong>源同步I/O</strong>：对于需要采集源同步数据的I/O接口，建议使用<code>BUFIO</code>，并结合<code>BUFG</code>以实现最佳性能</li>
</ul>
<h4 id="134-idelay">1.3.4 IDELAY原语的作用</h4>
<p><code>IDELAY</code>原语是Xilinx FPGA中用于对输入信号进行延迟调整的模块，主要用于处理高速串行接口、源同步接口等场景中的信号对齐问题。它在FPGA设计中具有重要作用，尤其是在需要精确控制信号延迟的场合。在使用IDELAY原语时，需要同时实例化<code>IDELAYCTRL</code>这个原语，否则在综合的时候会报错。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125201530.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125201530.png" /></a></p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125203335.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125203335.png" /></a></p>
<ol>
<li><strong>IDELAY原语的作用介绍</strong></li>
</ol>
<p><code>IDELAY</code>原语的主要作用是对输入信号施加可配置的延迟，以实现以下功能：</p>
<ul>
<li><strong>信号对齐</strong>：在高速串行接口或源同步接口中，输入信号和时钟信号之间可能存在相位偏差。通过<code>IDELAY</code>可以调整输入信号的延迟，使其与系统时钟对齐。</li>
<li><strong>延迟校准</strong>：在某些应用中，需要对输入信号的延迟进行动态调整，以补偿信号传输路径中的延迟变化。<code>IDELAY</code>可以实现这种动态延迟校准。</li>
<li>
<p><strong>消除亚稳态</strong>：在跨时钟域信号传输中，通过调整延迟可以减少亚稳态的影响。</p>
</li>
<li>
<p><strong>IDELAY的类型</strong></p>
</li>
</ul>
<p>Xilinx FPGA提供了多种类型的延迟模块，常见的有：</p>
<ul>
<li><strong><code>IDELAY</code></strong>：基本的输入延迟模块。</li>
<li><strong><code>IDELAYE2</code></strong>：增强型输入延迟模块，支持更多的功能和更灵活的配置。</li>
<li>
<p><strong><code>IDELAYE3</code></strong>：进一步增强的输入延迟模块，适用于更复杂的延迟调整需求。</p>
</li>
<li>
<p><strong>IDELAYE2的配置参数</strong></p>
</li>
</ul>
<p><code>IDELAYE2</code>是常用的增强型输入延迟模块，它支持多种配置参数，以下是一些关键参数：</p>
<ul>
<li><strong><code>DELAY_SRC</code></strong>：指定延迟的输入源，可以是<code>DATAIN</code>（来自<code>IDELAY</code>模块的输入信号）或<code>IDATAIN</code>（来自用户逻辑的输入信号）。</li>
<li><strong><code>DELAY_TYPE</code></strong>：指定延迟的类型，可以是：</li>
<li><code>FIXED</code>：固定延迟。</li>
<li><code>VARIABLE</code>：可变延迟。</li>
<li><code>VAR_LOAD</code>：可变延迟，延迟值可以通过<code>LD</code>和<code>LD价值</code>动态加载。</li>
<li><strong><code>DELAY_VALUE</code></strong>：指定延迟的初始值，单位是<code>ps</code>（皮秒）。</li>
<li><strong><code>REFCLK_FREQUENCY</code></strong>：参考时钟频率，单位是<code>MHz</code>。</li>
<li>
<p><strong><code>HIGH_PERFORMANCE_MODE</code></strong>：高性能量子延迟模式，可以提高延迟的精度。</p>
</li>
<li>
<p><strong>使用场景</strong></p>
</li>
<li>
<p><strong>高速串行接口</strong>：在高速串行接口中，输入信号和时钟信号之间可能存在相位偏差。通过<code>IDELAY</code>可以调整输入信号的延迟，使其与系统时钟对齐。</p>
</li>
<li><strong>源同步接口</strong>：在源同步接口中，输入信号和时钟信号是同步传输的。通过<code>IDELAY</code>可以调整输入信号的延迟，以确保数据的正确采样。</li>
<li>
<p><strong>跨时钟域信号传输</strong>：在跨时钟域信号传输中，通过调整延迟可以减少亚稳态的影响。</p>
</li>
<li>
<p><strong>注意事项</strong></p>
</li>
<li>
<p><strong>延迟范围</strong>：<code>IDELAY</code>的延迟范围是有限的，通常在<code>0ps</code>到<code>1000ps</code>之间。如果需要更大的延迟，可能需要结合其他延迟模块。</p>
</li>
<li><strong>参考时钟</strong>：<code>IDELAY</code>需要一个参考时钟来控制延迟的更新。参考时钟的频率需要与设计中的时钟频率匹配。</li>
<li>
<p><strong>动态调整</strong>：在动态调整延迟时，需要确保延迟值的更新不会导致信号的不稳定。</p>
</li>
<li>
<p><strong>IDELAYE2的实例化代码</strong></p>
</li>
</ul>
<pre><code class="language-verilog">   IDELAYE2 #(
      .CINVCTRL_SEL(&quot;FALSE&quot;),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC(&quot;IDATAIN&quot;),           // Delay input (IDATAIN, DATAIN)
      .HIGH_PERFORMANCE_MODE(&quot;FALSE&quot;), // Reduced jitter (&quot;TRUE&quot;), Reduced power (&quot;FALSE&quot;)
      .IDELAY_TYPE(&quot;FIXED&quot;),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
      .PIPE_SEL(&quot;FALSE&quot;),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN(&quot;DATA&quot;)          // DATA, CLOCK input signal
   )
   IDELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
       .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output，延时后的输出信号
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Internal delay data input
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the I/O
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Load IDELAY_VALUE input
      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enable PIPELINE register to load data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );
</code></pre>
<p>注意在这里，注意<code>IDATAIN</code>和<code>DATAIN</code>两个输入端口，我们实际上只需要将我们要延时的数据输入进一个端口即可，当我们的数据源处于FPGA内部时，将<code>IDATAIN</code>置0，将数据连接进<code>DATAIN</code>中，并且修改参数.<code>DELAY_SRC("DATAIN"),</code>。反之将反</p>
<ol>
<li><strong>IDELAYCTRL原语实例化</strong></li>
</ol>
<pre><code class="language-verilog">   IDELAYCTRL IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input
   );

</code></pre>
<h4 id="135-iddr">1.3.5 IDDR原语的作用</h4>
<p><code>IDDR</code>（Input Double Data Rate）原语是Xilinx FPGA中用于处理双倍数据速率（DDR）信号的底层原语，其主要功能是将输入的双沿信号（DDR）转换为单沿信号（SDR），以便FPGA内部逻辑能够正确处理。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204016.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204016.png" /></a></p>
<ol>
<li>
<p><strong>功能与作用</strong></p>
</li>
<li>
<p><strong>双沿信号转换</strong>：<code>IDDR</code>能够将输入的双沿信号（在时钟上升沿和下降沿都传输数据）转换为单沿信号（仅在时钟上升沿或下降沿传输数据），从而将输入的DDR信号转换为FPGA内部可处理的SDR信号。</p>
</li>
<li>
<p><strong>提高数据吞吐率</strong>：通过在每个时钟边沿捕获数据，<code>IDDR</code>可以在相同的时钟频率下实现双倍的数据传输速率。</p>
</li>
<li>
<p><strong>工作模式</strong></p>
</li>
</ol>
<p><code>IDDR</code>支持以下三种工作模式：下面有详细的模式介绍和时序图，注意观察Q1和Q2的数据排布，最常用的是第三个<code>SAME_EDGE_PIPELINED</code></p>
<ol>
<li><strong>OPPOSITE_EDGE</strong>：在时钟的上升沿捕获输入信号的上升沿数据，并在下降沿捕获输入信号的下降沿数据。捕获的数据分别输出到<code>Q1</code>和<code>Q2</code>。<a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204422.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204422.png" /></a></li>
<li><strong>SAME_EDGE</strong>：在时钟的同一边沿（通常是上升沿）捕获输入信号的上升沿和下降沿数据。<a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204441.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204441.png" /></a></li>
<li>
<p><strong>SAME_EDGE_PIPELINED</strong>：与<code>SAME_EDGE</code>类似，但数据输出会延迟一个时钟周期。<a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204457.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250125204457.png" /></a></p>
</li>
<li>
<p><strong>参数配置</strong></p>
</li>
<li>
<p><strong><code>DDR_CLK_EDGE</code></strong>：设置工作模式，可选值为<code>OPPOSITE_EDGE</code>、<code>SAME_EDGE</code>或<code>SAME_EDGE_PIPELINED</code>。</p>
</li>
<li><strong><code>INIT_Q1</code>、<code>INIT_Q2</code></strong>：设置输出<code>Q1</code>和<code>Q2</code>的初始值。</li>
<li>
<p><strong><code>SRTYPE</code></strong>：设置复位类型，可选值为<code>SYNC</code>（同步复位）或<code>ASYNC</code>（异步复位）。</p>
</li>
<li>
<p><strong>端口说明</strong></p>
</li>
<li>
<p><strong><code>Q1</code>、<code>Q2</code></strong>：单沿数据输出，分别对应输入信号的上升沿和下降沿数据。</p>
</li>
<li><strong><code>C</code></strong>：时钟输入。</li>
<li><strong><code>CE</code></strong>：时钟使能信号，必须为高电平才能捕获数据。</li>
<li><strong><code>D</code></strong>：输入的双沿数据。</li>
<li><strong><code>R</code>、<code>S</code></strong>：复位和置位信号。</li>
</ol>
<p><strong>实例化代码</strong>:</p>
<pre><code class="language-verilog">   IDDR #(
      .DDR_CLK_EDGE(&quot;OPPOSITE_EDGE&quot;), // &quot;OPPOSITE_EDGE&quot;, &quot;SAME_EDGE&quot; 
                                      //    or &quot;SAME_EDGE_PIPELINED&quot; 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );
</code></pre>
<h4 id="136-rgmii">1.3.6 RGMII接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-14 19:21:05
 * @LastEditTime: 2025-02-14 20:07:03
 * @FilePath: \rtl\rgmii_recive.v
 * @Description:添加信号的IBUF、BUFIO、BUFG、延时控制、IDDR原语，信号过BUF原语进行提高信号质量，过IDDR原语将rgmii双边沿信号转换位gmii单边沿信号
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */


module rgmii_recieve(
    input wire          sys_reset_n               ,
    input wire          idelay_refclk       ,

    input wire          phy_rgmii_rx_clk    ,
    input wire          phy_rgmii_rx_ctl    ,
    input wire [3:0]    phy_rgmii_rx_data   ,

    output wire         gmii_rx_clk         ,
    output wire         gmii_rx_data_vld    ,
    output wire         gmii_rx_data_error  ,
    output wire [7:0]   gmii_rx_data        
);
wire            phy_rgmii_rx_clk_ibuf       ;
wire            phy_rgmii_rx_ctl_ibuf       ;
wire  [3:0]     phy_rgmii_rx_data_ibuf      ;

wire            phy_rgmii_rx_clk_ibuf_bufio ;
wire            phy_rgmii_rx_ctl_ibuf_delay ;
wire  [3:0]     phy_rgmii_rx_data_ibuf_delay;

/*--------------------------------------------------*\
                       IBUF
\*--------------------------------------------------*/
//对phy_rgmii_rx_clk信号通过buf
   IBUF #(
      .IBUF_LOW_PWR(&quot;TRUE&quot;),        // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      .IOSTANDARD(&quot;DEFAULT&quot;)        // Specify the input I/O standard
   ) phy_rgmii_rx_clk_IBUF_inst (
      .O(phy_rgmii_rx_clk_ibuf),    // Buffer output
      .I(phy_rgmii_rx_clk)          // Buffer input (connect directly to top-level port)
   );
//对phy_rgmii_rx_ctl信号通过buf
   IBUF #(
      .IBUF_LOW_PWR(&quot;TRUE&quot;),        // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      .IOSTANDARD(&quot;DEFAULT&quot;)        // Specify the input I/O standard
   ) phy_rgmii_rx_ctl_IBUF_inst (
      .O(phy_rgmii_rx_ctl_ibuf),    // Buffer output
      .I(phy_rgmii_rx_ctl)          // Buffer input (connect directly to top-level port)
   );
//对phy_rgmii_rx_data信号通过buf
genvar i_rx;
generate
    for (i_rx = 0; i_rx &lt; 4; i_rx = i_rx + 1) begin
        IBUF #(
            .IBUF_LOW_PWR(&quot;TRUE&quot;),              // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
            .IOSTANDARD(&quot;DEFAULT&quot;)              // Specify the input I/O standard
        ) phy_rgmii_rx_data_IBUF_inst (
            .O(phy_rgmii_rx_data_ibuf[i_rx]),   // Buffer output
            .I(phy_rgmii_rx_data[i_rx])         // Buffer input (connect directly to top-level port)
        );
    end
endgenerate

/*--------------------------------------------------*\
                       BUFIO、BUFG
\*--------------------------------------------------*/
// 对时钟信号phy_rgmii_rx_clk_ibuf通过BUFIO和BUFG
   BUFIO phy_rgmii_rx_clk_ibuf_BUFIO_inst (
      .O(phy_rgmii_rx_clk_ibuf_bufio), // 1-bit output: Clock output (connect to I/O clock loads).
      .I(phy_rgmii_rx_clk_ibuf)  // 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   BUFG phy_rgmii_rx_clk_ibuf_BUFG_inst (
      .O(gmii_rx_clk), // 1-bit output: Clock output
      .I(phy_rgmii_rx_clk_ibuf)  // 1-bit input: Clock input
   );

/*--------------------------------------------------*\
                IDELAYCTRL、IDELAYE2       
\*--------------------------------------------------*/
IDELAYCTRL idelay_refclk_IDELAYCTRL_inst (
    .RDY(),       // 1-bit output: Ready output
    .REFCLK(idelay_refclk), // 1-bit input: Reference clock input
    .RST(1'b0)        // 1-bit input: Active high reset input
   );
 IDELAYE2 #(
      .CINVCTRL_SEL(&quot;FALSE&quot;),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC(&quot;IDATAIN&quot;),           // Delay input (IDATAIN, DATAIN)
      .HIGH_PERFORMANCE_MODE(&quot;FALSE&quot;), // Reduced jitter (&quot;TRUE&quot;), Reduced power (&quot;FALSE&quot;)
      .IDELAY_TYPE(&quot;FIXED&quot;),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
      .PIPE_SEL(&quot;FALSE&quot;),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN(&quot;DATA&quot;)          // DATA, CLOCK input signal
   )
   phy_rgmii_rx_ctl_ibuf_delay_IDELAYE2_inst (
      .CNTVALUEOUT(), // 5-bit output: Counter value output
      .DATAOUT(phy_rgmii_rx_ctl_ibuf_delay),         // 1-bit output: Delayed data output
      .C(0),                     // 1-bit input: Clock input
      .CE(0),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(0),       // 1-bit input: Dynamic clock inversion input
      .CNTVALUEIN(0),   // 5-bit input: Counter value input
      .DATAIN(0),           // 1-bit input: Internal delay data input
      .IDATAIN(phy_rgmii_rx_ctl_ibuf),         // 1-bit input: Data input from the I/O
      .INC(0),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(0),                   // 1-bit input: Load IDELAY_VALUE input
      .LDPIPEEN(0),       // 1-bit input: Enable PIPELINE register to load data input
      .REGRST(0)            // 1-bit input: Active-high reset tap-delay input
   );
genvar j_rx;
generate
    for (j_rx = 0; j_rx &lt; 4; j_rx = j_rx + 1) begin

        IDELAYE2 #(
            .CINVCTRL_SEL(&quot;FALSE&quot;),          // Enable dynamic clock inversion (FALSE, TRUE)
            .DELAY_SRC(&quot;IDATAIN&quot;),           // Delay input (IDATAIN, DATAIN)
            .HIGH_PERFORMANCE_MODE(&quot;FALSE&quot;), // Reduced jitter (&quot;TRUE&quot;), Reduced power (&quot;FALSE&quot;)
            .IDELAY_TYPE(&quot;FIXED&quot;),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
            .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
            .PIPE_SEL(&quot;FALSE&quot;),              // Select pipelined mode, FALSE, TRUE
            .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
            .SIGNAL_PATTERN(&quot;DATA&quot;)          // DATA, CLOCK input signal
        )phy_rgmii_rx_data_ibuf_delay_IDELAYE2_inst (
            .IDATAIN(phy_rgmii_rx_data_ibuf[j_rx]),         // 1-bit input: Data input from the I/O      
            .DATAOUT(phy_rgmii_rx_data_ibuf_delay[j_rx]),         // 1-bit output: Delayed data output
            .CNTVALUEOUT(), // 5-bit output: Counter value output      
            .C(0),                     // 1-bit input: Clock input
            .CE(0),                   // 1-bit input: Active high enable increment/decrement input
            .CINVCTRL(0),       // 1-bit input: Dynamic clock inversion input
            .CNTVALUEIN(0),   // 5-bit input: Counter value input
            .DATAIN(0),           // 1-bit input: Internal delay data input
            .INC(0),                 // 1-bit input: Increment / Decrement tap delay input
            .LD(0),                   // 1-bit input: Load IDELAY_VALUE input
            .LDPIPEEN(0),       // 1-bit input: Enable PIPELINE register to load data input
            .REGRST(0)            // 1-bit input: Active-high reset tap-delay input
            );

    end
endgenerate

/*--------------------------------------------------*\
                       IDDR原语 
\*--------------------------------------------------*/
IDDR #(
      .DDR_CLK_EDGE(&quot;SAME_EDGE_PIPELINED&quot;), // &quot;OPPOSITE_EDGE&quot;, &quot;SAME_EDGE&quot; 
                                      //    or &quot;SAME_EDGE_PIPELINED&quot; 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; 
   ) gmii_rx_data_vld_IDDR_inst (
      .Q1(gmii_rx_data_vld), // 1-bit output for positive edge of clock
      .Q2(gmii_rx_data_error_xor), // 1-bit output for negative edge of clock
      .C(phy_rgmii_rx_clk_ibuf_bufio),   // 1-bit clock input
      .CE(1), // 1-bit clock enable input
      .D(phy_rgmii_rx_ctl_ibuf_delay),   // 1-bit DDR data input
      .R(0),   // 1-bit reset
      .S(0)    // 1-bit set
   );

genvar q_rx;
generate

    for (q_rx = 0; q_rx &lt; 4; q_rx = q_rx + 1) begin

        IDDR #(
            .DDR_CLK_EDGE(&quot;SAME_EDGE_PIPELINED&quot;), // &quot;OPPOSITE_EDGE&quot;, &quot;SAME_EDGE&quot;                                 //    or &quot;SAME_EDGE_PIPELINED&quot; 
            .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
            .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
            .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; 
        ) gmii_rx_data_IDDR_inst (
            .Q1(gmii_rx_data[q_rx]), // 1-bit output for positive edge of clock
            .Q2(gmii_rx_data[q_rx + 4]), // 1-bit output for negative edge of clock
            .C(phy_rgmii_rx_clk_ibuf_bufio),   // 1-bit clock input
            .CE(1), // 1-bit clock enable input
            .D(phy_rgmii_rx_data_ibuf_delay[q_rx]),   // 1-bit DDR data input
            .R(0),   // 1-bit reset
            .S(0)    // 1-bit set
   );

   end
endgenerate
endmodule
</code></pre>
<h4 id="137">1.3.7 代码仿真代码与验证</h4>
<h3 id="14-rgmiirgmii_sendv">1.4 RGMII发送模块代码编写：rgmii_send.v</h3>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250210113253.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250210113253.png" /></a></p>
<h4 id="141">1.4.1 模块设计思路</h4>
<p>这个模块是RGMII发送数据模块，查看上面的模块框图可以看出来，它接收来自上游的数据（GMII 格式）。该模块的功能主要是将GMII格式的时钟和数据转换成RGMII格式的时钟和数据传出。</p>
<p>与RGMII接收模块类似，发送模块也是利用了FPGA中的一些基本原语来处理时钟和数据的转换的，主要用到了<code>ODDR (输出双数据率触发器)</code>和 <code>OBUF (输出缓冲器)</code>两个原语，这两个原语的介绍在下面也进行的详细的解释。</p>
<p>这个模块比较简单，不需要通过BUF原语多次处理时钟和其他信号确保时序的稳定了，因为这是发送模块，这些数据都是FPGA内向外部传输的。</p>
<p>我们只需要通过<code>ODDR</code>原语 将 <code>gmii_tx_data_vld</code> 信号（GMII 数据有效标志）转换为 RGMII 的 <code>phy_rgmii_tx_ctl</code> 信号。将 <code>gmii_tx_data</code>GMII 数据（8 位）转换为 4 位的 <code>phy_rgmii_tx_data</code>RGMII 数据。</p>
<h4 id="142-oddr">1.4.2 ODDR原语的作用</h4>
<p>Vivado 中的 <strong>ODDR 原语</strong>（Output Double Data Rate）是 FPGA 设计中用于实现 <strong>单数据速率（SDR）到双数据速率（DDR）转换</strong> 的关键组件。它通过时钟的 <strong>上升沿和下降沿</strong> 分别发送数据，从而将数据传输速率提升一倍。以下是关于 ODDR 原语的详细介绍：</p>
<p><strong>1. ODDR 的核心作用</strong></p>
<ul>
<li><strong>DDR 信号生成</strong>：将 FPGA 内部逻辑的单数据速率信号转换为双数据速率信号，满足高速接口（如 DDR 存储器、LVDS、HDMI 等）的时序要求。</li>
<li><strong>时钟域对齐</strong>：通过同步时钟边沿输出数据，确保数据与外部设备时钟严格对齐。</li>
<li><strong>资源优化</strong>：直接调用 FPGA 的专用硬件资源（如 I/O 触发器），避免通用逻辑资源浪费。</li>
</ul>
<p><strong>2.ODDR 的结构与信号定义</strong></p>
<p>ODDR 原语的接口通常包含以下关键信号：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">信号名</th>
<th style="text-align: left;">方向</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>C</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">主时钟，驱动数据传输的基准时钟。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>D1</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">在时钟 <strong>上升沿</strong> 锁存并输出的数据。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>D2</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">在时钟 <strong>下降沿</strong> 锁存并输出的数据。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Q</strong></td>
<td style="text-align: left;">输出</td>
<td style="text-align: left;">DDR 输出信号，交替输出 D1 和 D2 的值。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>CE</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">时钟使能信号（可选），高电平时允许数据锁存。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>R</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">同步复位信号（可选），复位输出为初始值。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;">输入</td>
<td style="text-align: left;">同步置位信号（可选），置位输出为高电平。</td>
</tr>
</tbody>
</table>
<p><strong>3. ODDR 的工作模式</strong></p>
<p>ODDR 支持两种模式，通过参数 <code>DDR_CLK_EDGE</code> 配置：</p>
<p><strong>(1) OPPOSITE_EDGE 模式</strong></p>
<ul>
<li><strong>行为</strong>：D1 在时钟 <strong>上升沿</strong> 被锁存，D2 在 <strong>下降沿</strong> 被锁存。</li>
<li><strong>输出时序</strong>：
  https://www.xilinx.com/content/dam/xilinx/support/documentation/ip_documentation/ug471_7Series_SelectIO.pdf</li>
<li>时钟上升沿 → 输出 D1。</li>
<li>时钟下降沿 → 输出 D2。</li>
<li><strong>适用场景</strong>：传统 DDR 接口设计，需严格匹配外部设备时序。</li>
</ul>
<p><strong>(2) SAME_EDGE 模式</strong></p>
<ul>
<li><strong>行为</strong>：D1 和 D2 均在时钟 <strong>上升沿</strong> 被锁存，但 D2 的值会延迟半个周期输出。</li>
<li><strong>输出时序</strong>：
  https://www.xilinx.com/content/dam/xilinx/support/documentation/ip_documentation/ug471_7Series_SelectIO.pdf</li>
<li>时钟上升沿 → 输出 D1。</li>
<li>下一时钟上升沿 → 输出 D2（内部延迟半周期）。</li>
<li><strong>优势</strong>：简化 FPGA 内部逻辑时序设计，避免跨时钟域问题。</li>
</ul>
<p><strong>4. ODDR 的典型应用场景</strong></p>
<ol>
<li><strong>DDR 存储器接口</strong></li>
<li>与 DDR SDRAM 通信时，需通过 ODDR 生成符合 JEDEC 标准的 DQS 和 DQ 信号。</li>
<li><strong>高速串行接口</strong></li>
<li>如 LVDS、HDMI 的时钟和数据通道，需 DDR 信号提升传输效率。</li>
<li><strong>时钟转发（Clock Forwarding）</strong></li>
<li>将 FPGA 内部时钟通过 DDR 模式输出，供外部芯片同步使用。</li>
<li><strong>数据对齐</strong></li>
<li>在源同步接口（如 Camera Link）中，对齐数据与随路时钟。</li>
</ol>
<p><strong>5.实例化代码</strong></p>
<pre><code class="language-verilog">ODDR #(
    .DDR_CLK_EDGE(&quot;OPPOSITE_EDGE&quot;), // 工作模式：OPPOSITE_EDGE 或 SAME_EDGE
    .INIT(1'b0),                    // 输出初始值（0 或 1）
    .SRTYPE(&quot;SYNC&quot;)                 // 复位/置位类型：SYNC（同步）或 ASYNC（异步）
) ODDR_inst (
    .Q(Q),   // DDR 输出信号
    .C(clk), // 基准时钟（需与外部设备时钟同源）
    .CE(1'b1), // 时钟使能（常接高电平）
    .D1(data_rise), // 上升沿数据
    .D2(data_fall), // 下降沿数据
    .R(1'b0), // 复位（通常禁用）
    .S(1'b0)  // 置位（通常禁用）
);
</code></pre>
<p><strong>6. 关键配置参数详解</strong></p>
<ul>
<li><strong><code>DDR_CLK_EDGE</code></strong>
  决定数据锁存边沿模式，需根据外部设备时序要求选择。</li>
<li><strong><code>INIT</code></strong>
  初始化输出值，通常设为 0 或 1，需与接口空闲状态一致。</li>
<li><strong><code>SRTYPE</code></strong>
  复位/置位信号的同步方式：</li>
<li><code>SYNC</code>：复位/置位与时钟同步。</li>
<li><code>ASYNC</code>：复位/置位异步生效（可能导致时序违例）。</li>
</ul>
<h4 id="143-rgmii">1.4.3 RGMII发送模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-14 19:21:29
 * @LastEditTime: 2025-02-14 20:08:08
 * @FilePath: \rtl\rgmii_send.v
 * @Description:添加信号的OBUF、ODDR原语
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

module rgmii_send(
    input wire          sys_reset_n              ,
    input wire          gmii_tx_clk        ,
    input wire          gmii_tx_data_vld   ,
    input wire [7:0]    gmii_tx_data       ,

    output wire         phy_rgmii_tx_clk   ,
    output wire         phy_rgmii_tx_ctl   ,
    output wire [3:0]   phy_rgmii_tx_data  
);

wire       rgmii_tx_ctl;
wire [3:0] rgmii_tx_data;

/*--------------------------------------------------*\
                       ODDR原语
\*--------------------------------------------------*/
   ODDR #(
      .DDR_CLK_EDGE(&quot;SAME_EDGE&quot;), // &quot;OPPOSITE_EDGE&quot; or &quot;SAME_EDGE&quot; 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; 
   ) ODDR_ctl(
      .Q(rgmii_tx_ctl),   // 1-bit DDR output
      .C(gmii_tx_clk),   // 1-bit clock input
      .CE(1), // 1-bit clock enable input
      .D1(gmii_tx_data_vld), // 1-bit data input (positive edge)
      .D2(gmii_tx_data_vld ), // 1-bit data input (negative edge) //注意不要掉了异或
      .R(0),   // 1-bit reset
      .S(0)    // 1-bit set
   );
genvar i_tx;
generate
    for (i_tx = 0; i_tx &lt; 4; i_tx = i_tx + 1) begin

        ODDR #(
            .DDR_CLK_EDGE(&quot;SAME_EDGE&quot;), // &quot;OPPOSITE_EDGE&quot; or &quot;SAME_EDGE&quot; 
            .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
            .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; 
        ) ODDR_data(
            .Q(rgmii_tx_data[i_tx]),   // 1-bit DDR output
            .C(gmii_tx_clk),   // 1-bit clock input
            .CE(1), // 1-bit clock enable input
            .D1(gmii_tx_data[i_tx]), // 1-bit data input (positive edge)
            .D2(gmii_tx_data[i_tx + 4]), // 1-bit data input (negative edge)
            .R(0),   // 1-bit reset
            .S(0)    // 1-bit set
        );

    end
endgenerate


/*--------------------------------------------------*\
                       OBUF原语
\*--------------------------------------------------*/
 OBUF OBUF_clk (
      .O(phy_rgmii_tx_clk), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(gmii_tx_clk)  // 1-bit input: Buffer input
   );

   OBUF OBUF_ctl (
      .O(phy_rgmii_tx_ctl), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(rgmii_tx_ctl)  // 1-bit input: Buffer input
   );

genvar j_tx;
generate
    for (j_tx = 0; j_tx &lt; 4; j_tx = j_tx + 1) begin

        OBUF OBUF_data 
        (
            .O(phy_rgmii_tx_data[j_tx]), // 1-bit output: Buffer output (connect directly to top-level port)
            .I(rgmii_tx_data[j_tx])  // 1-bit input: Buffer input

        );      
    end
endgenerate

endmodule
</code></pre>
<h4 id="144">1.4.4 代码仿真与验证</h4>
<h3 id="15-udp">1.5 UDP协议栈架构设计及时钟规划</h3>
<h3 id="16-macmac_receivevv">1.6 MAC接收模块代码编写：mac_receivev.v</h3>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250216184302.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250216184302.png" /></a></p>
<h4 id="161">1.6.1 模块设计思路</h4>
<p>以太网帧结构如下：</p>
<pre><code>| 前导码(7B) | SFD(1B) | 目标MAC(6B) | 源MAC(6B) | 类型(2B) | 数据(46-1500B) | CRC(4B) |
</code></pre>
<p>首先，我们再次梳理整体项目的思路，我们的数据是从PC机中经过rgmii_receive模块将数据从rgmii格式转换到gmii格式后，将数据传递给mac_receive模块对以太网帧进行解析并去掉包头（包括前导码、SFD、目标MAC、源MAC、类型）后传递给下一层ip_receive模块的。所以在这个模块中，核心的功能应该有下面几点：</p>
<ol>
<li>接收来自rgmii_receive的数据</li>
<li>完成以太网帧解析、校验和有效数据的传递</li>
<li>有效数据的需要经过SFD、CRC校验后传输以及跨时钟域处理，可以通过FIFO对数据的缓存来实现</li>
</ol>
<p>具体来说：</p>
<ol>
<li>对以太网帧前导码、目标MAC地址、帧类型字段的提取</li>
<li>前导码/SFD校验、MAC地址过滤、CRC校验</li>
<li>跨时钟域传输，通过双时钟FIFO实现从PHY时钟域到系统时钟域的数据传输</li>
<li>将数据存储在FIFO中，当校验通过后，数据有效信号再拉高表示数据没有问题</li>
</ol>
<p>关于这个模块的接口信息如上图所示：</p>
<ul>
<li>
<p>输入<code>sys_clk</code> 和<code>sys_reset_n</code>系统时钟和复位信号</p>
</li>
<li>
<p>输入来自<code>phy_rx_clk</code>和 <code>phy_rx_reset</code> 来自phy芯片的时钟和复位信号</p>
</li>
<li>输入来自rgmii_recieve模块的<code>gmii_rx_data_vld</code>和<code>gmii_rx_data</code> 的数据有效信号和数据信号</li>
<li>输入来自crc32_d8模块的计算结果的数据</li>
<li>输出处理后的数据，包括<code>mac_rx_data_vld</code>（数据有效信号）,<code>mac_rx_data_last</code>（数据结束标识信号）,<code>mac_rx_data</code>（输出数据信号），<code>mac_rx_frame_type</code>（以太网帧类型字段信号），传递给mac_to_arp_ip模块进行针对不同的以太网帧字段类型选择不同的处理方式</li>
</ul>
<h4 id="162">1.6.2 状态机逻辑讲解</h4>
<p>关于状态机的内容，相比看到这里的读者对状态机的写法还是无比熟悉了，在这里我想再次给大家重新梳理一下状态机的一些知识点和笔试面试中常见的问法，大家若是感觉自己已经很熟练了，可以跳过这部分内容。</p>
<p>FPGA是并行执行的，如果说我们想要处理一个前后顺序的事件该怎么办呐，这时候就需要我们的状态机来完成了。状态机的基本类型分下面两类：</p>
<ul>
<li><strong>Moore型状态机</strong>：输出仅由当前状态决定，与输入无关。</li>
<li><strong>Mealy型状态机</strong>：输出由当前状态和输入共同决定。</li>
</ul>
<p>在我们要完成一个完整的状态机逻辑之前，需要先设计绘制状态转移图，明确转移条件和跳转关系，</p>
<p>此外，完整的状态机应该包含<strong>状态寄存器</strong>、<strong>下一状态逻辑</strong>、<strong>输出逻辑</strong>这三个部分组成，下面我们一步一步来编写一个简单的状态机demo。</p>
<h5 id="1621verilog">1.6.2.1状态机的Verilog实现步骤</h5>
<h6 id="1_2">（1）状态定义</h6>
<p>使用<code>parameter</code>定义所有可能的状态，通常推荐独热码（One-Hot）或二进制编码：</p>
<pre><code class="language-verilog">// 示例：4个状态（独热码）
parameter IDLE  = 4'b0001,
          STATE1 = 4'b0010,
          STATE2 = 4'b0100,
          STATE3 = 4'b1000;
</code></pre>
<h6 id="2_1">（2）状态寄存器</h6>
<p>用时序逻辑（<code>always @(posedge clk</code>）更新当前状态：</p>
<pre><code class="language-verilog">reg [3:0] current_state, next_state;

always @(posedge clk or posedge reset) begin
    if (reset) 
        current_state &lt;= IDLE; // 复位到初始状态
    else 
        current_state &lt;= next_state;
end
</code></pre>
<h6 id="3_1">（3）下一状态逻辑</h6>
<p>用组合逻辑（<code>always @*</code>）根据输入和当前状态计算下一状态：</p>
<pre><code class="language-verilog">always @(*) begin
    case (current_state)
        IDLE: 
            if (start) next_state = STATE1;
            else      next_state = IDLE;
        STATE1: 
            if (input_a) next_state = STATE2;
            else         next_state = IDLE;
        STATE2: 
            next_state = STATE3; // 无条件跳转
        STATE3: 
            if (done)   next_state = IDLE;
            else        next_state = STATE3;
        default: 
            next_state = IDLE; // 避免锁存器
    endcase
end
</code></pre>
<h6 id="4_1">（4）输出逻辑</h6>
<ul>
<li><strong>Moore型</strong>：输出仅依赖当前状态：</li>
</ul>
<p><code>verilog
  always @(*) begin
      case (current_state)
          IDLE:   output = 0;
          STATE1:  output = 1;
          STATE2:  output = 0;
          STATE3:  output = 1;
      endcase
  end</code></p>
<ul>
<li><strong>Mealy型</strong>：输出依赖当前状态和输入：</li>
</ul>
<p><code>verilog
  always @(*) begin
      if (current_state == STATE1 &amp;&amp; input_a) 
          output = 1;
      else 
          output = 0;
  end</code></p>
<p>在笔试面试中常见的问题就是自动贩卖机和交通信号灯的状态机编写，下面我们通过梳理实现思路，绘制状态转移图和编写模块代码和仿真代码进行实验</p>
<h5 id="1622-1">1.6.2.2 应用案例1：自动贩卖机示例</h5>
<p>输入信号有：钱的投入金额、商品选择</p>
<p>输出信号有：不同商品出货信号</p>
<p>状态机状态：等待投币，投入硬币、选择商品、出货状态、恢复状态</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250217213431.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250217213431.png" /></a></p>
<p><strong>选择商品：</strong>用户可以选择商品（<code>product1</code>、<code>product2</code> 或 <code>product3</code>）。只有在选择商品后，才会进入 <code>COIN_INPUT</code> 状态进行投入硬币。</p>
<p><strong>投入硬币</strong>：在 <code>COIN_INPUT</code> 状态，系统会根据用户选择的商品判断是否足够支付。如果足够，进入 <code>DISPENSE</code> 状态，进行商品出货。如果余额不足，系统会继续等待硬币投入</p>
<p><strong>交易完成：</strong>跳转到恢复等待，然后跳转到初始状态</p>
<p><strong>模块代码和仿真代码如下：</strong></p>
<pre><code class="language-verilog">module vending_machine(
    input clk,              // 时钟信号
    input reset,            // 复位信号
    input coin_5,           // 5元硬币投入
    input coin_10,          // 10元硬币投入
    input coin_25,          // 25元硬币投入
    input product1,         // 选择商品1
    input product2,         // 选择商品2
    input product3,         // 选择商品3
    output reg dispense_product1,   // 商品1出货信号
    output reg dispense_product2,   // 商品2出货信号
    output reg dispense_product3    // 商品3出货信号
);

parameter IDLE       = 3'b000,
          SELECT     = 3'b001,
          COIN_INPUT = 3'b010,
          DISPENSE   = 3'b011,
          RESTORE    = 3'b100;

reg [2:0] current_state, next_state;
reg [7:0] current_balance;
reg [7:0] product1_price = 50;  // 商品1价格：50元
reg [7:0] product2_price = 75;  // 商品2价格：75元
reg [7:0] product3_price = 100; // 商品3价格：100元

// 状态寄存器
always @(posedge clk or posedge reset) begin
    if (reset)
        current_state &lt;= IDLE;
    else
        current_state &lt;= next_state;
end

// 当前余额更新逻辑
always @(posedge clk or posedge reset) begin
    if (reset)
        current_balance &lt;= 0;
    else if (current_state == COIN_INPUT) begin
        if (coin_5) current_balance &lt;= current_balance + 5;
        if (coin_10) current_balance &lt;= current_balance + 10;
        if (coin_25) current_balance &lt;= current_balance + 25;
    end
end

// 下一状态逻辑
always @(*) begin
    case (current_state)
        IDLE: next_state = SELECT;
        SELECT: next_state = (product1 || product2 || product3) ? COIN_INPUT : SELECT;
        COIN_INPUT: next_state = (product1 &amp;&amp; current_balance &gt;= product1_price) ? DISPENSE : 
                                 (product2 &amp;&amp; current_balance &gt;= product2_price) ? DISPENSE : 
                                 (product3 &amp;&amp; current_balance &gt;= product3_price) ? DISPENSE : COIN_INPUT;
        DISPENSE: next_state = RESTORE;
        RESTORE: next_state = IDLE;
        default: next_state = IDLE;
    endcase
end

// 输出逻辑
always @(*) begin
    dispense_product1 = 0;
    dispense_product2 = 0;
    dispense_product3 = 0;

    case (current_state)
        IDLE: begin
            dispense_product1 = 0;
            dispense_product2 = 0;
            dispense_product3 = 0;
        end
        SELECT: begin
            dispense_product1 = 0;
            dispense_product2 = 0;
            dispense_product3 = 0;
        end
        COIN_INPUT: begin
            dispense_product1 = 0;
            dispense_product2 = 0;
            dispense_product3 = 0;
        end
        DISPENSE: begin
            if (product1) dispense_product1 = 1;
            else if (product2) dispense_product2 = 1;
            else if (product3) dispense_product3 = 1;
        end
        RESTORE: begin
            dispense_product1 = 0;
            dispense_product2 = 0;
            dispense_product3 = 0;
        end
    endcase
end

endmodule

</code></pre>
<pre><code class="language-verilog">module vending_machine_tb;

    reg clk;
    reg reset;
    reg coin_5;
    reg coin_10;
    reg coin_25;
    reg product1;
    reg product2;
    reg product3;
    wire dispense_product1;
    wire dispense_product2;
    wire dispense_product3;

    // 实例化自动贩卖机模块
    vending_machine vm (
        .clk(clk),
        .reset(reset),
        .coin_5(coin_5),
        .coin_10(coin_10),
        .coin_25(coin_25),
        .product1(product1),
        .product2(product2),
        .product3(product3),
        .dispense_product1(dispense_product1),
        .dispense_product2(dispense_product2),
        .dispense_product3(dispense_product3)
    );

    // 时钟生成
    always begin
        #5 clk = ~clk;  // 10ns周期的时钟
    end

    // 仿真过程
    initial begin
        // 初始化信号
        clk = 0;
        reset = 0;
        coin_5 = 0;
        coin_10 = 0;
        coin_25 = 0;
        product1 = 0;
        product2 = 0;
        product3 = 0;

        // 复位
        reset = 1;
        #10 reset = 0;

        // 投入硬币
        coin_5 = 1; #10 coin_5 = 0;
        coin_10 = 1; #10 coin_10 = 0;
        coin_25 = 1; #10 coin_25 = 0;

        // 选择商品1
        product1 = 1; #10 product1 = 0;

        // 继续选择商品2
        product2 = 1; #10 product2 = 0;

        // 查看输出
        #20;

        // 停止仿真
        $stop;
    end
endmodule

</code></pre>
<h5 id="1623-2">1.6.2.3 应用案例2：交通信号灯示例</h5>
<p>在完成这个代码的时候，我们先对其进行分析一下，设计一个十字路口的交通信号灯控制器，<strong>东西方向</strong>和<strong>南北方向</strong>交替通行，一个方向绿灯/黄灯时，另一个方向必须为红灯，此外<strong>绿灯亮30秒 → 黄灯亮5秒 → 红灯亮</strong>。状态转移图如下所示：</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250217210949.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250217210949.png" /></a></p>
<p><strong>模块代码和仿真代码如下：</strong></p>
<pre><code class="language-verilog">module traffic_light (
    input      clk,
    input      reset,
    output reg ew_red,
    output reg ew_yellow,
    output reg ew_green,
    output reg ns_red,
    output reg ns_yellow,
    output reg ns_green
);

parameter IDLE      = 3'b000,
          EW_GREEN  = 3'b001,
          EW_YELLOW = 3'b010,
          NS_GREEN  = 3'b011,
          NS_YELLOW = 3'b100;

reg [2:0] current_state, next_state;
reg [5:0] timer;

// 状态寄存器
always @(posedge clk or posedge reset) begin
    if (reset)
        current_state &lt;= IDLE;
    else
        current_state &lt;= next_state;
end

// 定时器逻辑
always @(posedge clk or posedge reset) begin
    if (reset)
        timer &lt;= 0;
    else begin
        if (timer == 0)
            timer &lt;= (current_state == EW_GREEN)  ? 30 :
                     (current_state == EW_YELLOW) ? 5  :
                     (current_state == NS_GREEN)  ? 30 :
                     (current_state == NS_YELLOW) ? 5  : 0;
        else
            timer &lt;= timer - 1;
    end
end

// 下一状态逻辑
always @(*) begin
    case (current_state)
        IDLE:      next_state = EW_GREEN;
        EW_GREEN:  next_state = (timer == 0) ? EW_YELLOW : EW_GREEN;
        EW_YELLOW: next_state = (timer == 0) ? NS_GREEN  : EW_YELLOW;
        NS_GREEN:  next_state = (timer == 0) ? NS_YELLOW : NS_GREEN;
        NS_YELLOW: next_state = (timer == 0) ? EW_GREEN  : NS_YELLOW;
        default:   next_state = IDLE;
    endcase
end

// 输出逻辑
always @(*) begin
    ew_red = 0; ew_yellow = 0; ew_green = 0;
    ns_red = 0; ns_yellow = 0; ns_green = 0;

    case (current_state)
        IDLE: begin
            ew_red = 1;
            ns_red = 1;
        end
        EW_GREEN: begin
            ew_green = 1;
            ns_red   = 1;
        end
        EW_YELLOW: begin
            ew_yellow = 1;
            ns_red    = 1;
        end
        NS_GREEN: begin
            ns_green = 1;
            ew_red   = 1;
        end
        NS_YELLOW: begin
            ns_yellow = 1;
            ew_red    = 1;
        end
    endcase
end

endmodule
</code></pre>
<pre><code class="language-verilog">module tb_traffic_light();
    reg clk, reset;
    wire ew_red, ew_yellow, ew_green;
    wire ns_red, ns_yellow, ns_green;

    traffic_light uut (
        .clk(clk),
        .reset(reset),
        .ew_red(ew_red),
        .ew_yellow(ew_yellow),
        .ew_green(ew_green),
        .ns_red(ns_red),
        .ns_yellow(ns_yellow),
        .ns_green(ns_green)
    );

    initial begin
        clk = 0;
        reset = 1;
        #10 reset = 0; // 复位后释放
    end

    always #5 clk = ~clk; // 10ns周期（假设1秒=10ns）

    initial begin
        $monitor(&quot;Time=%0t: EW=[R:%b Y:%b G:%b], NS=[R:%b Y:%b G:%b]&quot;,
                 $time, ew_red, ew_yellow, ew_green, ns_red, ns_yellow, ns_green);
        #500 $finish;
    end
endmodule
</code></pre>
<h4 id="163-fifofifo">1.6.3 深入理解FIFO的底层资源（设置FIFO的位宽和深度即类型）</h4>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250218101849.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250218101849.png" /></a></p>
<p>在 Vivado 中，FIFO IP 核的底层资源实现与 FPGA 的物理架构密切相关，主要涉及 Block RAM（BRAM）、分布式 RAM（Distributed RAM）、移位寄存器（SRL）以及逻辑资源（LUT/FF）。</p>
<p>首先，FIFO的类型可以分为<strong>同步FIFO</strong>和<strong>异步FIFO</strong>两大类：</p>
<ul>
<li><strong>同步FIFO：</strong>读写共享同一个时钟，无需跨时钟域</li>
<li><strong>异步FIFO</strong>：读写时钟独立，除了存储数据，还有跨时钟域处理的用途</li>
</ul>
<p>接着，我们区分一下常听说的的BRAM、DRAM以</p>
<ul>
<li><strong>Block RAM</strong>：强制使用 BRAM，适合大容量或高频率场景。BRAM是FPGA有限的BRAM硬件资源，分为18k和32k，用一个少一个。在配置BRAM的宽度和深度的时候，一般建议选择将数据补零后占满当前资源量的最大值，充分利用BRAM资源。</li>
</ul>
<blockquote>
<p>1个18k的BRAM能存储多少数据呐？</p>
<p>1个18k的BRAM总共能存储18432bit = 9(宽度)*2048(深度) = 18(宽度) * 1024(深度) = 32(宽度) * 512(深度)</p>
<p>一个32k的BRAM能存储多少数据呐</p>
<p>示例：1024x32 FIFO → 总存储量 = 32,768b，需 1 块 36K BRAM（36,864b），相当于两个18k的BRAM级联得到。</p>
</blockquote>
<ul>
<li><strong>Distributed RAM</strong>：强制使用 LUT，适合浅 FIFO 或低延迟需求。它消耗的是FPGA的逻辑资源，所以当数据量大的时候，对FPGA逻辑资源很不友好，所以适合存储像命令一类的数据</li>
</ul>
<h4 id="164-gmii">1.6.4 GMII输入信号延迟处理逻辑</h4>
<h4 id="165-sfdmaccrc">1.6.5 校验逻辑实现（前导码、SFD、MAC地址、crc数据校验内容）</h4>
<p>mac_receive模块作为数据从phy芯片传向FPGA做的第一次实际处理的模块，在这个模块中数据处理的逻辑毋庸置疑是最重要的内容，这里讲解校验逻辑的实现，只有当所有的校验通过后，我们的数据才会作为一个真正有效的数据向下传递，否则则会判定为非法帧而被过滤。</p>
<p>我们需要再次回忆这个模块接收到的数据到底是一个什么样的结构组成，我给大家绘制了一张图像，一目了然：</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250218143603.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250218143603.png" /></a></p>
<p>1.前导码和帧开始符是固定的，为7个0x55紧跟着1个0xd5
2.目的MAC地址指明帧的接受者
3.源MAC地址指明帧的发送者
4.以太网类型，指示帧的类型，比如0x0800表示该帧是IP数据包，0x0806表示该帧是ARP协议数据包
5.数据和填充就是所承载的数据包，跟前面以太网类型对应。
6.帧校验序列是一个32位的循环校验码（FCS）。
　　每一个设备都有一个不同的MAC地址，当一个设备A发送一个以太网帧，源MAC地址是自己的MAC地址，目的MAC地址如果是0xffffff，此时就是广播，所有与之连接的设备都会收到该帧，如果目的MAC地址是一个独特的MAC地址，那么本地MAC地址与之相同的设备将会接收到该以太网帧，然后通过判断以太网帧类型，进行下一步数据包解析。
那么下面我们来详细说明每一个校验逻辑（关于CRC校验逻辑，请参考下面的内容单独讲）</p>
<h4 id="166-mac">1.6.6 以太网数据帧分离（剥离有效数据和mac包头)</h4>
<p>剥离接收到的以太网头部，包括前导码(7Byte)、SFD(1Byte)、目标MAC地址(6Byte)、源MAC地址(6Byte)、Type和Length(2Byte)。</p>
<p>通过使用字节计数器进行剥离数据，下面是详细的代码逻辑文件</p>
<h4 id="167-mac">1.6.7 MAC层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-10 22:03:40
 * @LastEditTime: 2025-02-17 07:09:17
 * @FilePath: \rtl\mac_receive.v
 * @Description: 以太网MAC接收模块，负责处理GMII接口数据，进行CRC校验，分离MAC头和有效数据，并跨时钟域传输：
                1. 接收GMII数据流，解析前导码、目标MAC地址、帧类型
                2. CRC校验（可选，设置CRC_CHECK_EN为高时开启crc校验）
                3. 使用双时钟FIFO实现跨时钟域传输
                4. 输出有效数据、帧类型和校验结果
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved. 
 * ****************************************************************************************
 */
// 程序存在问题，在实例化这个模块时，crc端口没有被实际连接在crc32_d8模块中,在此端口中crc32_d8的交互信号方向存在疑惑

module mac_receive#(
    parameter LOCAL_MAC_ADDR    = 48'hffffffffffff, // 本地MAC地址，用于匹配接收的MAC地址
    parameter CRC_CHECK_EN      = 1'b1              // CRC校验使能，1为启用，0为禁用
)(
    input               sys_clk             , // 系统接收时钟
    input               phy_rx_clk          , // phy芯片接收端时钟
    input               phy_rx_reset        , // phy芯片接收端复位信号
    input               sys_reset_n         , // 系统复位信号

    /*-------与rgmii_recieve模块交互信号--------*/
    input               gmii_rx_data_vld    , // GMII数据有效信号
    input [7:0]         gmii_rx_data        , // GMII接收数据

    /*-------与mac_to_arp_ip模块的交互信号--------*/
    output reg          mac_rx_data_vld     , // 输出数据有效
    output reg          mac_rx_data_last    , // 输出数据结束标志
    output reg [7:0]    mac_rx_data         , // 输出数据内容
    output reg [15:0]   mac_rx_frame_type   , // 以太网帧类型字段

    /*-------与rx_crc32_d8模块交互信号--------*/
    output reg          rx_crc_din_vld      , // CRC计算数据有效
    output reg [7:0]    rx_crc_din          , // CRC计算输入数据
    output reg          rx_crc_done         , // CRC计算完成信号
    input [31:0]        rx_crc_dout           // CRC计算结果输入

);
/*--------------------------------------------------*\
                       状态机信号定义
\*--------------------------------------------------*/
reg [2:0] cur_status            ; // 当前状态
reg [2:0] nxt_status            ; // 下一状态
localparam RX_IDLE = 3'b000     ; // 空闲状态：等待帧开始
localparam RX_PRE = 3'b001      ; // 前导码处理：读取帧信息
localparam RX_DATA = 3'b010     ; // 数据传输：输出有效数据
localparam RX_END = 3'b100      ; // 结束状态：完成以太网数据帧处理

/*--------------------------------------------------*\
                       接收MAC信号
\*--------------------------------------------------*/
reg [15:0]  rx_frame_type       ; // 帧类型字段（2字节）
reg [47:0]  rx_target_mac       ; // 目标MAC地址（6字节）
reg [10:0]  rx_cnt              ; // 接收计数器：统计有效数据字节数
reg [55:0]  rx_preamble         ; // 存储前导码（7字节）
reg         rx_preamble_chack   ; // 前导码校验结果，正确情况下应为7byte的0x55（固定值，参考我们的文档）
reg         rx_sfd_chack        ; // SFD校验结果（第7字节为0xD5）正确情况下应为1byte的0xd5（固定值，参考我们的文档
reg         rx_target_mac_chack ; // 目标MAC校验（本地MAC或广播地址）
reg         frame_fifo_crc      ; 
reg         rx_crc_chack        ; // CRC校验结果
reg         rx_wr_vld           ;

/*--------------------------------------------------*\
                       打拍信号：用于时序对齐
\*--------------------------------------------------*/
reg         gmii_rx_data_vld_d0     ;
reg         gmii_rx_data_vld_d1     ;
reg         gmii_rx_data_vld_d2     ;
reg         gmii_rx_data_vld_d3     ;
reg         gmii_rx_data_vld_d4     ;
reg [7:0]   gmii_rx_data_d0         ;
reg [7:0]   gmii_rx_data_d1         ;
reg [7:0]   gmii_rx_data_d2         ;
reg [7:0]   gmii_rx_data_d3         ;
reg [7:0]   gmii_rx_data_d4         ;

wire        rx_data_last            ;
reg         rx_data_last_d0         ;
reg         rx_data_last_d1         ;
reg         rx_data_last_d2         ;
reg         rx_data_last_d3         ;
reg         rx_data_last_d4         ;
reg         rx_data_last_d5         ;
reg         rx_data_last_d6         ;

/*--------------------------------------------------*\
                       FIFO端口信号
\*--------------------------------------------------*/
// 帧信息FIFO：存储帧类型和CRC校验结果
reg [16:0]  frame_din              ; // 帧FIFO数据输入
reg         frame_wren             ; // 帧FIFO写使能
wire [16:0] frame_dout             ; // 帧FIFO数据输出
reg         frame_rden             ; // 帧FIFO读使能
wire        frame_wrfull           ; // 帧FIFO写满标志
wire        frame_rdempty          ; // 帧FIFO读空标志
wire [3:0]  frame_wrcount          ; // 帧FIFO写计数
wire [3:0]  frame_rdcount          ; // 帧FIFO读计数

// 数据FIFO：存储有效载荷数据和结束标志
reg [8:0]   data_din               ; // 数据FIFO数据输入
reg         data_wren              ; // 数据FIFO写使能
wire [8:0]  data_dout              ; // 数据FIFO数据输出
reg         data_rden              ; // 数据FIFO读使能
wire        data_wrfull            ; // 数据FIFO写满标志
wire        data_rdempty           ; // 数据FIFO读空标志
wire [11:0] data_wrcount           ; // 数据FIFO写计数
wire [11:0] data_rdcount           ; // 数据FIFO读计数


//数据结束检测：利用有效信号的下降沿检测
assign rx_data_last = ~gmii_rx_data_vld &amp; gmii_rx_data_vld_d0;


// GMII输入信号延迟处理（5级延迟用于时序对齐）
always @(posedge phy_rx_clk) begin
    gmii_rx_data_vld_d0 &lt;= gmii_rx_data_vld;
    gmii_rx_data_vld_d1 &lt;= gmii_rx_data_vld_d0;
    gmii_rx_data_vld_d2 &lt;= gmii_rx_data_vld_d1;
    gmii_rx_data_vld_d3 &lt;= gmii_rx_data_vld_d2;
    gmii_rx_data_vld_d4 &lt;= gmii_rx_data_vld_d3;

    gmii_rx_data_d0     &lt;= gmii_rx_data;
    gmii_rx_data_d1     &lt;= gmii_rx_data_d0;
    gmii_rx_data_d2     &lt;= gmii_rx_data_d1;
    gmii_rx_data_d3     &lt;= gmii_rx_data_d2; 
    gmii_rx_data_d4     &lt;= gmii_rx_data_d3; 

    rx_data_last_d0     &lt;= rx_data_last;
    rx_data_last_d1     &lt;= rx_data_last_d0;
    rx_data_last_d2     &lt;= rx_data_last_d1;
    rx_data_last_d3     &lt;= rx_data_last_d2;
    rx_data_last_d4     &lt;= rx_data_last_d3; 
    rx_data_last_d5     &lt;= rx_data_last_d4;     
    rx_data_last_d6     &lt;= rx_data_last_d5; 
end

/*--------------------------------------------------*\
            rx_cnt:接收计数器,统计有效数据字节数
\*--------------------------------------------------*/
// 在phy_rx_clk时钟下进行计数，
always @(posedge phy_rx_clk) begin
    if (phy_rx_reset) 
        rx_cnt &lt;= 0;
    else if (gmii_rx_data_vld_d4) //打5拍计数
        rx_cnt &lt;= rx_cnt + 1;
    else 
        rx_cnt &lt;= 0;
end


/*--------------------------------------------------*\
    校验preamble、sfd、mac addr
\*--------------------------------------------------*/
// 所有校验通过后，数据才会被后续模块处理，确保非法帧被过滤  
// 前导码移位寄存器的实现
always @(posedge phy_rx_clk) begin
    if (gmii_rx_data_vld_d4 &amp;&amp; rx_cnt &lt; 7) // rx_cnt &lt; 7 对应以太网前导码的 7 个 0x55
        rx_preamble &lt;= {rx_preamble[47:0], gmii_rx_data_d4}; // 左移拼接新字节
    else 
        rx_preamble &lt;= rx_preamble; // 保持当前值
end
// 前导码校验逻辑
always @(posedge phy_rx_clk) begin
    if (rx_preamble == 56'h5555_5555_5555_55) 
        rx_preamble_chack &lt;= 1'b1; // 前导码正确
    else 
        rx_preamble_chack &lt;= 1'b0; // 前导码错误
end

// SFD校验逻辑
// rx_cnt == 7 表示第 8 个有效数据字节（前导码占 7 字节，SFD 是第 8 字节）
always @(posedge phy_rx_clk) begin
    if (rx_cnt == 7 &amp;&amp; gmii_rx_data_d4 == 8'hd5) 
        rx_sfd_chack &lt;= 1'b1; // SFD正确
    else 
        rx_sfd_chack &lt;= 1'b0; // SFD错误
end


// 目标MAC地址移位寄存器的实现
// rx_cnt &gt; 7 &amp;&amp; rx_cnt &lt; 14 表示第 9-14 字节（SFD 后紧跟 6 字节目标MAC地址）
always @(posedge phy_rx_clk) begin
    if (gmii_rx_data_vld_d4 &amp;&amp; rx_cnt &gt; 7 &amp;&amp; rx_cnt &lt; 14) 
        rx_target_mac &lt;= {rx_target_mac[39:0], gmii_rx_data_d4}; // 右移拼接新字节
    else 
        rx_target_mac &lt;= rx_target_mac; // 保持当前值
end

// 目标MAC地址校验逻辑
always @(posedge phy_rx_clk) begin
    if (rx_target_mac == LOCAL_MAC_ADDR || rx_target_mac == 48'hffffffffffff) 
        rx_target_mac_chack &lt;= 1'b1; // 匹配本地MAC或广播地址
    else 
        rx_target_mac_chack &lt;= 1'b0; // 不匹配
end
/*--------------------------------------------------*\
                       CRC校验模块
\*--------------------------------------------------*/
// 提取数值后传递给crc32_d8模块，
generate
    if (CRC_CHECK_EN == 0) begin
        // 禁用CRC校验时，直接标记为通过
        always @(posedge phy_rx_clk) begin
            rx_crc_chack &lt;= 1'b1; // 强制通过
        end
    end else if (CRC_CHECK_EN == 1) begin
        reg         crc_en;     // CRC计算使能
        reg [31:0]  rc_crc;     // 接收端提取的CRC值

        // CRC计算使能控制
        always @(posedge phy_rx_clk) begin
            if (rx_cnt == 7)         // 第8字节（目标MAC开始）
                crc_en &lt;= 1;         // 启动CRC计算
            else if (rx_data_last)   // 数据结束时
                crc_en &lt;= 0;         // 停止计算
        end

        // 连接CRC模块的接口
        always @(posedge phy_rx_clk) begin
            rx_crc_din_vld &lt;= crc_en;       // 有效信号
            rx_crc_din     &lt;= gmii_rx_data_d4; // 输入数据（对齐后）
            rx_crc_done    &lt;= rx_data_last_d6; // 计算完成信号（延迟6周期）
        end

        // 接收端CRC提取（从数据尾部）
        always @(posedge phy_rx_clk) begin
            // 在最后4个周期（rx_data_last_d0~d3）提取CRC值
            if (rx_data_last_d0 || rx_data_last_d1 || rx_data_last_d2 || rx_data_last_d3) 
                rc_crc &lt;= {gmii_rx_data_d4, rc_crc[31:8]}; // 小端转换
        end

        // CRC校验结果比较
        always @(posedge phy_rx_clk) begin
            if (rx_data_last_d5) // 延迟到CRC计算完成
                rx_crc_chack &lt;= (rc_crc == rx_crc_dout); // 校验结果
        end
    end
endgenerate

/*--------------------------------------------------*\
                       数据写入FIFO
\*--------------------------------------------------*/
// 帧类型提取（第21-22字节）
always @(posedge phy_rx_clk) begin
    if (gmii_rx_data_vld_d4 &amp;&amp; rx_cnt &gt; 19 &amp;&amp; rx_cnt &lt; 22) 
        rx_frame_type &lt;= {rx_frame_type[7:0], gmii_rx_data_d4}; // 拼接为16位
    end


// 帧信息写入frame_fifo（CRC结果 + 帧类型）
always @(posedge phy_rx_clk) begin
    if (rx_data_last_d6 &amp;&amp; rx_preamble_chack &amp;&amp; rx_sfd_chack &amp;&amp; rx_target_mac_chack) begin
        frame_din  &lt;= {rx_crc_chack, rx_frame_type}; // [16:0] = {1bit CRC, 16bit Type}
        frame_wren &lt;= 1'b1;
    end
    else begin
        frame_din  &lt;= frame_din;
        frame_wren &lt;= 1'b0;
    end 
end

// 有效数据写入data_fifo（数据 + 结束标志）
always @(posedge phy_rx_clk) begin
    if (rx_preamble_chack &amp;&amp; rx_sfd_chack &amp;&amp; rx_target_mac_chack &amp;&amp; gmii_rx_data_vld_d4 &amp;&amp; rx_cnt == 21) 
       rx_wr_vld &lt;= 1'b1; 
    else if (rx_data_last) 
       rx_wr_vld &lt;= 1'b0;  
end

always @(posedge phy_rx_clk) begin
    data_wren &lt;= rx_wr_vld;
    data_din  &lt;= {rx_data_last,gmii_rx_data_d4}; // [8:0] = {1bit Last, 8bit Data}
end
/*--------------------------------------------------*\
                       状态机控制
\*--------------------------------------------------*/
// 时序逻辑：状态机当前状态寄存器
always @(posedge sys_clk or negedge sys_reset_n) begin
    if (!sys_reset_n) begin
        cur_status &lt;= RX_IDLE; // 异步复位，状态机回复到空闲状态
    end else begin
        cur_status &lt;= nxt_status; // 同步更新到下一状态
    end
end

// 组合逻辑：计算下一状态
always @(*) begin
    // 默认下一状态保持当前状态
    nxt_status = cur_status; 

    // 在组合逻辑中处理下一状态转换
    case (cur_status)
        RX_IDLE: begin
            if (~frame_rdempty) begin
                nxt_status = RX_PRE; // 如果帧FIFO不为空，进入前导码状态
            end
        end
        RX_PRE: begin
            nxt_status = RX_DATA; // 前导码状态后进入数据状态
        end
        RX_DATA: begin
            if (data_rden &amp;&amp; data_dout[8]) begin
                nxt_status = RX_END; // 数据读取完成且遇到包尾时，进入结束状态
            end
        end
        RX_END: begin
            nxt_status = RX_IDLE; // 结束状态后回到空闲状态
        end
        default: begin
            nxt_status = RX_IDLE; // 默认（非法）状态，回到空闲
        end
    endcase
end

/*--------------------------------------------------*\
                       FIFO读数据
\*--------------------------------------------------*/
// 组合逻辑：控制帧FIFO读使能信号
always @(*) begin
    frame_rden = (cur_status == RX_PRE); // 仅在前导码状态时使能帧FIFO读取
end

always @(posedge sys_clk) begin
    if (frame_rden) begin
        mac_rx_frame_type &lt;= frame_dout[15:0];
        frame_fifo_crc    &lt;= frame_dout[16];
    end
end

always @(posedge sys_clk) begin
    if (cur_status == RX_PRE) 
        data_rden &lt;= 1'b1;
    else if (cur_status == RX_DATA &amp;&amp; data_rden &amp;&amp; data_dout[8]) 
        data_rden &lt;= 1'b0;
    else 
        data_rden &lt;= data_rden;
end

always @(posedge sys_clk) begin
    if (data_rden &amp;&amp; frame_fifo_crc) begin
        mac_rx_data      &lt;= data_dout[7:0];
        mac_rx_data_last &lt;= data_dout[8];
        mac_rx_data_vld  &lt;= 1'b1;
    end
    else begin
        mac_rx_data      &lt;= 0;
        mac_rx_data_last &lt;= 0;
        mac_rx_data_vld  &lt;= 0;
    end 
end

/*--------------------------------------------------*\
                       FIFO实例化
\*--------------------------------------------------*/
fifo_w17xd16 frame_fifo (
  .rst(phy_rx_reset),                      // input wire rst
  .wr_clk(phy_rx_clk),                // input wire wr_clk
  .rd_clk(sys_clk),                // input wire rd_clk
  .din(frame_din),                      // input wire [16 : 0] din
  .wr_en(frame_wren),                  // input wire wr_en
  .rd_en(frame_rden),                  // input wire rd_en
  .dout(frame_dout),                    // output wire [16 : 0] dout
  .full(frame_wrfull),                    // output wire full
  .empty(frame_rdempty),                  // output wire empty
  .rd_data_count(frame_rdcount),  // output wire [3 : 0] rd_data_count
  .wr_data_count(frame_wrcount)  // output wire [3 : 0] wr_data_count
);

fifo_w9xd4096 data_fifo (
  .rst(phy_rx_reset),                      // input wire rst
  .wr_clk(phy_rx_clk),                // input wire wr_clk
  .rd_clk(sys_clk),                // input wire rd_clk
  .din(data_din),                      // input wire [8 : 0] din
  .wr_en(data_wren),                  // input wire wr_en
  .rd_en(data_rden),                  // input wire rd_en
  .dout(data_dout),                    // output wire [8 : 0] dout
  .full(data_wrfull),                    // output wire full
  .empty(data_rdempty),                  // output wire empty
  .rd_data_count(data_rdcount),  // output wire [11 : 0] rd_data_count
  .wr_data_count(data_wrcount)  // output wire [11 : 0] wr_data_count
);

endmodule

</code></pre>
<h4 id="168-mac_to_arp_ipv">1.6.8 mac_to_arp_ip.v模块编写</h4>
<pre><code>/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-17 16:14:13
 * @LastEditTime: 2025-02-17 16:27:58
 * @FilePath: rtl/mac_to_arp_ip.v
 * @Description:核心作用是根据以太网帧类型字段，将MAC层接收的数据分发至上层协议处理模块（ARP/IP）
 1. 协议符合时直通链路，协议不符合时数据静默清零
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module mac_to_arp_ip(
    /*-------系统接口--------*/
    input           sys_clk             ,
    input           sys_reset_n         ,

    /*-------MAC接收接口--------*/
    input           mac_rx_data_vld     ,
    input           mac_rx_data_last    ,
    input [7:0]     mac_rx_data         ,
    input [15:0]    mac_rx_frame_type   ,  

    /*-------IP协议接口--------*/
    output reg      ip_rx_data_vld      ,
    output reg      ip_rx_data_last     ,
    output reg [7:0]ip_rx_data          ,

    /*-------ARP协议接口--------*/
    output reg      arp_rx_data_vld     ,
    output reg      arp_rx_data_last    ,
    output reg [7:0]arp_rx_data             
 );
/*--------------------------------------------------*\
                       协议类型识别机制
\*--------------------------------------------------*/
// ARP协议：0x0806
// IPv4协议：0x0800
// IPv6协议：0x86DD（当前设计未实现）
localparam ARP_TYPE = 16'h0806;  // ARP协议类型值（IEEE标准定义）
localparam IP_TYPE  = 16'h0800;  // IPv4协议类型值

/*--------------------------------------------------*\
                       IP数据通道控制
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (mac_rx_frame_type == IP_TYPE) begin
        ip_rx_data_vld  &lt;=  mac_rx_data_vld;
        ip_rx_data_last &lt;=  mac_rx_data_last;
        ip_rx_data      &lt;=  mac_rx_data;
    end
    else begin
        ip_rx_data_vld  &lt;=  0;
        ip_rx_data_last &lt;=  0;
        ip_rx_data      &lt;=  0;  
    end     
end

/*--------------------------------------------------*\
                       ARP数据通道控制
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (mac_rx_frame_type == ARP_TYPE) begin
        arp_rx_data_vld  &lt;=  mac_rx_data_vld;
        arp_rx_data_last &lt;=  mac_rx_data_last;
        arp_rx_data      &lt;=  mac_rx_data;
    end
    else begin
        arp_rx_data_vld  &lt;=  0;
        arp_rx_data_last &lt;=  0;
        arp_rx_data      &lt;=  0;  
    end     
end

 endmodule
</code></pre>
<h4 id="168">1.6.8 代码仿真与验证</h4>
<h3 id="17-macmac_sendv">1.7 MAC发送模块代码编写：mac_send.v</h3>
<p>MAC发送代码模块的主要功能将数据添加MAC头部，包含前导码、MAC头部、源MAC地址、目标MAC地址，类型与长度以及CRC校验。最后将数据传递给rgmii_send.v模块进行发送给phy芯片，最后将数据传输到外部。</p>
<p>在这个工程里面除了刚刚讲到的组包和CRC校验的过程，还涉及到系统时钟域sys_clk跨域到PHY时钟域phy_tx_clk。</p>
<h4 id="171-mac">1.7.1 添加MAC头部</h4>
<p>数据添加MAC头部时，与前面接收MAC数据包并刨析MAC数据头部原理时相似的，使用一个字节计数器，在状态机位TX_DATA的时候字节计数器激活，每一个phy时钟上升沿计数器加一用来计数。</p>
<p>使用case语句来对每一个字节位控制发送的数据位是什么，比如在下面的代码中，0-6发送的字节位8‘h55，在第七位发送8’hd5等等，原理很简单。</p>
<pre><code class="language-verilog">always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        tx_cnt &lt;= 0;
    else if (cur_status == TX_DATA) 
        tx_cnt &lt;= tx_cnt + 1; // 在数据阶段递增计数器
    else 
        tx_cnt &lt;= 0; // 其他状态复位计数器
end
always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        send_data &lt;= 0;
    else 
        case(tx_cnt)
            0,1,2,3,4,5,6  : send_data &lt;= 8'h55; //// 前导码（7字节0x55）+ 帧起始符（1字节0xD5）
            7              : send_data &lt;= 8'hd5; //帧起始定界符

            8              : send_data &lt;= send_target_mac_cdc[47:40]; // 目标MAC（6字节） 高位先发，9-13依次发送后续字节
            9              : send_data &lt;= send_target_mac_cdc[39:32];
            10             : send_data &lt;= send_target_mac_cdc[31:24];
            11             : send_data &lt;= send_target_mac_cdc[23:16];
            12             : send_data &lt;= send_target_mac_cdc[15:8];
            13             : send_data &lt;= send_target_mac_cdc[7:0];

            14             : send_data &lt;= LOCAL_MAC_ADDR[47:40]; // 源MAC（6字节）
            15             : send_data &lt;= LOCAL_MAC_ADDR[39:32];
            16             : send_data &lt;= LOCAL_MAC_ADDR[31:24];
            17             : send_data &lt;= LOCAL_MAC_ADDR[23:16];
            18             : send_data &lt;= LOCAL_MAC_ADDR[15:8];
            19             : send_data &lt;= LOCAL_MAC_ADDR[7:0];                                              

            20             : send_data &lt;= mac_type[15:8]; // 类型字段（2字节）
            21             : send_data &lt;= mac_type[7:0];  
            default        : send_data &lt;= data_dout[7:0]; // 有效载荷（从data_fifo读取）
        endcase 
end
</code></pre>
<h4 id="172">1.7.2 跨时钟域处理</h4>
<p>在进行跨时钟域处理时，同样使用异步FIFO缓存数据的方法对数据进行跨时钟域处理。使用位宽为64位，深度位16位的的fifo缓存帧信息，用位宽为9位，深度为4096的fifo缓存以太网有效数据，</p>
<h4 id="173-crc">1.7.3 CRC校验(循环冗余校验)</h4>
<p>在数据传输过程中，无论传输系统设计的多么完美，差错总会存在，这种差错可能是在传输链路中信号收到干扰导致一位数据从0突变成1，通过本教程，读者可深入理解 CRC32 的原理、硬件实现细节，并掌握该模块的正确使用方法，下面是详细的内容：</p>
<h5 id="1731-crc">1.7.3.1 什么是 CRC？</h5>
<p>CRC（Cyclic Redundancy Check，循环冗余校验）是一种数据检错算法，用于检测或校验数据传输/存储过程中是否发生错误。</p>
<ul>
<li><strong>核心思想</strong>：通过多项式除法，生成固定长度的校验码（如32位），附加到数据末尾。接收方通过重新计算校验码验证数据完整性。</li>
<li><strong>特点</strong>：</li>
<li>检错能力强（可检测单bit、双bit、突发错误等）</li>
<li>计算效率高（硬件实现简单）</li>
<li>广泛用于以太网、磁盘存储、ZIP压缩等场景。</li>
<li><strong>特性</strong>：</li>
<li>生成32位校验码</li>
<li>初始值为 <code>0xFFFFFFFF</code></li>
<li>输出结果取反（~）并反转位序（LSB first → MSB first）</li>
</ul>
<p><strong>1 发送端流程</strong></p>
<ol>
<li><strong>数据输入</strong>：将待发送的以太网帧数据（包括前导码、MAC头、负载）逐字节输入模块。</li>
<li><strong>CRC附加</strong>：数据输入完成后，将 <code>crc_dout</code> 附加到帧末尾。</li>
</ol>
<p><strong>2 接收端校验</strong></p>
<ol>
<li><strong>重新计算 CRC</strong>：接收数据时，重新计算 CRC 值（包括接收的 CRC 字段）。</li>
<li><strong>校验判定</strong>：若最终 CRC 值不为 <code>0xC704DD7B</code>（以太网 Magic Value），则判定数据错误。</li>
</ol>
<h5 id="1732-crc">1.7.3.2 CRC 计算原理</h5>
<p><strong>1 模二除法（核心算法）</strong>
CRC 的本质是模二多项式除法：</p>
<ul>
<li><strong>输入数据</strong> 视为一个二进制多项式（如 <code>0xA3</code> → <code>10100011</code> → <code>x^7 + x^5 + x + 1</code>）。</li>
<li><strong>生成多项式</strong> 为固定值（如CRC32多项式）。</li>
<li><strong>计算过程</strong>：数据多项式除以生成多项式，余数即为 CRC 值。</li>
</ul>
<p><strong>2 硬件实现（移位寄存器）</strong>
传统实现方式：</p>
<ul>
<li><strong>串行计算</strong>：逐比特移位异或。</li>
<li><strong>并行优化</strong>：通过组合逻辑预计算多个比特的异或关系，提升速度（如8位并行计算）。</li>
</ul>
<p><strong>3 并行化推导</strong>
并行计算的本质是预判多bit输入对寄存器的影响。</p>
<ul>
<li><strong>数学推导</strong>：
  根据多项式，列出每个寄存器位在8次移位后的表达式。
  例如，若输入8位数据 <code>D[7:0]</code>，则新的寄存器值 <code>CRC_new[31:0]</code> 是 <code>CRC_old[31:0]</code> 和 <code>D[7:0]</code> 的异或组合。</li>
<li><strong>组合逻辑展开</strong>：
  通过数学展开，得到每个寄存器位的更新方程（如代码中的 <code>crc_data[0] = ...</code>）。</li>
</ul>
<h5 id="1733"><strong>1.7.3.3模块代码解析</strong></h5>
<p><strong>1 输入处理</strong></p>
<pre><code>// 输入字节位序反转（MSB→LSB）
assign crc_din_r = {crc_din[0], crc_din[1], ..., crc_din[7]};
</code></pre>
<ul>
<li><strong>原因</strong>：CRC计算从LSB开始处理，而输入数据通常是MSB在前。</li>
</ul>
<p><strong>2 组合逻辑计算</strong>
代码中 <code>crc_data[31:0]</code> 的每个位均由异或表达式生成，例如：</p>
<pre><code>assign crc_data[0] = crc_din_r[6] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[30];
</code></pre>
<ul>
<li><strong>解释</strong>：
  根据多项式推导，<code>crc_data[0]</code> 的值由输入数据位和当前寄存器位的异或组合决定。</li>
</ul>
<p><strong>3 时序逻辑更新</strong></p>
<pre><code>always @(posedge sys_clk) begin
  if (!sys_reset_n) 
    crc_dout_r &lt;= 32'hffff_ffff; // 初始值
  else if (crc_done) 
    crc_dout_r &lt;= 32'hffff_ffff; // 复位
  else if (crc_din_vld)
    crc_dout_r &lt;= crc_data;       // 更新CRC值
end
</code></pre>
<ul>
<li><strong>关键点</strong>：</li>
<li>初始值和复位值均为 <code>0xFFFFFFFF</code>（IEEE 802.3要求）。</li>
<li>每个有效输入字节触发一次寄存器更新。</li>
</ul>
<p><strong>4 输出处理</strong></p>
<pre><code>assign crc_dout = ~{反转位序(crc_dout_r)};
</code></pre>
<ul>
<li><strong>步骤</strong>：</li>
<li>反转寄存器位序（<code>crc_dout_r[0]</code> → <code>crc_dout[31]</code>）。</li>
<li>对结果取反（~）。</li>
</ul>
<h5 id="1734">1.7.3.4完整计算流程</h5>
<p><strong>1 数据输入阶段</strong>
假设输入数据为 <code>0x01, 0x02, 0x03, 0x04</code>：</p>
<ul>
<li><strong>步骤</strong>：</li>
<li>复位寄存器（<code>crc_done=1</code>）。</li>
<li>依次输入字节，每个字节持续一个时钟周期（<code>crc_din_vld=1</code>）。</li>
<li>最后一个字节输入后，<code>crc_dout</code> 输出最终校验码。</li>
</ul>
<p><strong>2 计算过程示例</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">时钟周期</th>
<th style="text-align: left;">操作</th>
<th style="text-align: left;">寄存器值（crc_dout_r）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: left;">复位</td>
<td style="text-align: left;">0xFFFFFFFF</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">输入 0x01</td>
<td style="text-align: left;">更新为 CRC(0x01)</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">输入 0x02</td>
<td style="text-align: left;">更新为 CRC(0x01,0x02)</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">输入 0x03</td>
<td style="text-align: left;">更新为 CRC(0x01,0x02,0x03)</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">输入 0x04</td>
<td style="text-align: left;">更新为最终值</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">输出 <code>crc_dout</code></td>
<td style="text-align: left;">取反并反转位序</td>
</tr>
</tbody>
</table>
<h5 id="1735">1.7.3.5 总结</h5>
<p><strong>1 以太网帧结构</strong></p>
<p>复制</p>
<pre><code>| 前导码 | 目标MAC | 源MAC | 类型 | 数据 | CRC32 |
</code></pre>
<ul>
<li><strong>CRC位置</strong>：附加在数据字段末尾。</li>
</ul>
<p><strong>2 模块集成</strong></p>
<ul>
<li><strong>发送端</strong>：</li>
<li>将数据逐字节输入模块。</li>
<li>数据发送完成后，附加 <code>crc_dout</code> 到帧末尾。</li>
<li><strong>接收端</strong>：</li>
<li>重新计算 CRC，若结果不为 <code>0xC704DD7B</code>（以太网“Magic Value”），则判定数据错误。</li>
</ul>
<h5 id="1736"><strong>1.7.3.6 实际使用时的便捷方法</strong></h5>
<p><strong>1. 验证方法</strong></p>
<ul>
<li><strong>软件对比</strong>：
  使用 Python 计算同一数据的 CRC32：</li>
</ul>
<pre><code class="language-python">import binascii
data = bytes([0x01, 0x02, 0x03, 0x04])
crc = binascii.crc32(data) &amp; 0xFFFFFFFF
print(hex(crc)) # 输出应为模块计算结果
</code></pre>
<p><strong>2. 实用工具</strong></p>
<p>用Verilog算CRC已经有了两个比较不错的网站，可以在线生成Verilog代码，如：</p>
<ul>
<li>
<p>OutputLogic.com » CRC Generator</p>
</li>
<li>
<p>Generator for CRC HDL code</p>
</li>
</ul>
<p>它对应的开源库：GitHub - mbuesch/crcgen: Generator for CRC HDL code (VHDL, Verilog, MyHDL)</p>
<h5 id="1737">1.7.3.7 模块代码解析</h5>
<p>该模块采用经典的 <strong>并行 CRC 计算架构</strong>，由以下核心部分组成：</p>
<ol>
<li><strong>输入位序处理</strong></li>
<li><strong>组合逻辑计算核心</strong></li>
<li><strong>时序控制与寄存器更新</strong></li>
<li><strong>输出结果后处理</strong></li>
</ol>
<p><strong>1 模块接口</strong></p>
<pre><code>module crc32_d8(
    input        sys_clk,        // 系统时钟
    input        sys_reset_n,    // 同步复位（低有效）
    input        crc_din_vld,    // 输入数据有效
    input [7:0]  crc_din,        // 8位输入数据
    input        crc_done,       // 计算完成信号（复位寄存器）
    output [31:0] crc_dout       // CRC32 结果（小端序+取反）
);
</code></pre>
<p><strong>2 关键逻辑实现</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">代码段</th>
<th style="text-align: left;">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>输入位序反转</strong></td>
<td style="text-align: left;">将输入字节从 MSB-first 转为 LSB-first：<code>crc_din_r[7:0] = {crc_din[0], crc_din[1], ..., crc_din[7]}</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>组合逻辑计算</strong></td>
<td style="text-align: left;">32位并行计算，通过预推导的异或表达式更新 CRC 值（代码中 <code>crc_data[31:0]</code>）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>时序逻辑更新</strong></td>
<td style="text-align: left;">在时钟上升沿更新寄存器值，支持复位和流式输入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>输出处理</strong></td>
<td style="text-align: left;">结果取反并反转位序：<code>crc_dout = ~{crc_dout_r[0], crc_dout_r[1], ..., crc_dout_r[31]}</code></td>
</tr>
</tbody>
</table>
<h5 id="1738">1.7.3.8 完整代码工程</h5>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-14 18:08:12
 * @LastEditTime: 2025-02-15 16:30:28
 * @FilePath: \rtl\crc32_d8.v
 * @Description:基于IEEE 802.3标准的CRC32校验码生成器（8位并行计算）
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

module crc32_d8(
    input        sys_clk,         // 系统时钟
    input        sys_reset_n,       // 同步复位（高有效）

    // CRC计算控制接口
    input        crc_din_vld, // 输入数据有效信号
    input [7:0]  crc_din,     // 输入数据（8位并行）
    input        crc_done,    // 计算完成信号（复位CRC寄存器）

    // CRC输出接口
    output [31:0] crc_dout    // CRC32计算结果（小端序+取反）
);

/*--------------------------------------------------*\
                       内部信号定义
\*--------------------------------------------------*/
wire [7:0]  crc_din_r;      // 位序调整后的输入数据（LSB first）
reg  [31:0] crc_dout_r;     // CRC计算结果寄存器
wire [31:0] crc_data;       // 组合逻辑计算中间值

/*--------------------------------------------------*\
                       输出结果处理
\*--------------------------------------------------*/
// 最终输出处理：按以太网标准要求
// 1. 寄存器值取反（~）
// 2. 位序反转（[0]→[31]）
assign crc_dout = ~{
    crc_dout_r[0],  crc_dout_r[1],  crc_dout_r[2],  crc_dout_r[3], 
    crc_dout_r[4],  crc_dout_r[5],  crc_dout_r[6],  crc_dout_r[7],
    crc_dout_r[8],  crc_dout_r[9],  crc_dout_r[10], crc_dout_r[11],
    crc_dout_r[12], crc_dout_r[13], crc_dout_r[14], crc_dout_r[15],
    crc_dout_r[16], crc_dout_r[17], crc_dout_r[18], crc_dout_r[19],
    crc_dout_r[20], crc_dout_r[21], crc_dout_r[22], crc_dout_r[23],
    crc_dout_r[24], crc_dout_r[25], crc_dout_r[26], crc_dout_r[27],
    crc_dout_r[28], crc_dout_r[29], crc_dout_r[30], crc_dout_r[31]
};

/*--------------------------------------------------*\
                       输入数据位序处理 
\*--------------------------------------------------*/
// 将输入字节位序反转（MSB→LSB）
// 原因：CRC计算从数据LSB开始处理
assign crc_din_r = {
    crc_din[0], crc_din[1], crc_din[2], crc_din[3],
    crc_din[4], crc_din[5], crc_din[6], crc_din[7]
};

/*--------------------------------------------------*\
                        CRC组合逻辑计算
\*--------------------------------------------------*/
// 根据CRC32多项式推导的并行计算逻辑
// 多项式：x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
assign   crc_data[0] = crc_din_r[6] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[30];
assign   crc_data[1] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[2] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[3] = crc_din_r[7] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[31];
assign   crc_data[4] = crc_din_r[6] ^ crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[28] ^ crc_dout_r[30];
assign   crc_data[5] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[27] ^ crc_dout_r[28] ^ crc_dout_r[29] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[6] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[28] ^ crc_dout_r[29] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[7] = crc_din_r[7] ^ crc_din_r[5] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_din_r[0] ^ crc_dout_r[24] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[29] ^ crc_dout_r[31];
assign   crc_data[8] = crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[0] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[27] ^ crc_dout_r[28];
assign   crc_data[9] = crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_dout_r[1] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[28] ^ crc_dout_r[29];
assign   crc_data[10] = crc_din_r[5] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_din_r[0] ^ crc_dout_r[2] ^ crc_dout_r[24] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[29];
assign   crc_data[11] = crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[3] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[27] ^ crc_dout_r[28];
assign   crc_data[12] = crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[4] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[28] ^ crc_dout_r[29] ^ crc_dout_r[30];
assign   crc_data[13] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_dout_r[5] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[29] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[14] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[2] ^ crc_dout_r[6] ^ crc_dout_r[26] ^ crc_dout_r[27] ^ crc_dout_r[28] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[15] = crc_din_r[7] ^ crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[3] ^ crc_dout_r[7] ^ crc_dout_r[27] ^ crc_dout_r[28] ^ crc_dout_r[29] ^ crc_dout_r[31];
assign   crc_data[16] = crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[0] ^ crc_dout_r[8] ^ crc_dout_r[24] ^ crc_dout_r[28] ^ crc_dout_r[29];
assign   crc_data[17] = crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[1] ^ crc_dout_r[9] ^ crc_dout_r[25] ^ crc_dout_r[29] ^ crc_dout_r[30];
assign   crc_data[18] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[2] ^ crc_dout_r[10] ^ crc_dout_r[26] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[19] = crc_din_r[7] ^ crc_din_r[3] ^ crc_dout_r[11] ^ crc_dout_r[27] ^ crc_dout_r[31];
assign   crc_data[20] = crc_din_r[4] ^ crc_dout_r[12] ^ crc_dout_r[28];
assign   crc_data[21] = crc_din_r[5] ^ crc_dout_r[13] ^ crc_dout_r[29];
assign   crc_data[22] = crc_din_r[0] ^ crc_dout_r[14] ^ crc_dout_r[24];
assign   crc_data[23] = crc_din_r[6] ^ crc_din_r[1] ^ crc_din_r[0] ^ crc_dout_r[15] ^ crc_dout_r[24] ^ crc_dout_r[25] ^ crc_dout_r[30];
assign   crc_data[24] = crc_din_r[7] ^ crc_din_r[2] ^ crc_din_r[1] ^ crc_dout_r[16] ^ crc_dout_r[25] ^ crc_dout_r[26] ^ crc_dout_r[31];
assign   crc_data[25] = crc_din_r[3] ^ crc_din_r[2] ^ crc_dout_r[17] ^ crc_dout_r[26] ^ crc_dout_r[27];
assign   crc_data[26] = crc_din_r[6] ^ crc_din_r[4] ^ crc_din_r[3] ^ crc_din_r[0] ^ crc_dout_r[18] ^ crc_dout_r[24] ^ crc_dout_r[27] ^ crc_dout_r[28] ^ crc_dout_r[30];
assign   crc_data[27] = crc_din_r[7] ^ crc_din_r[5] ^ crc_din_r[4] ^ crc_din_r[1] ^ crc_dout_r[19] ^ crc_dout_r[25] ^ crc_dout_r[28] ^ crc_dout_r[29] ^ crc_dout_r[31];
assign   crc_data[28] = crc_din_r[6] ^ crc_din_r[5] ^ crc_din_r[2] ^ crc_dout_r[20] ^ crc_dout_r[26] ^ crc_dout_r[29] ^ crc_dout_r[30];
assign   crc_data[29] = crc_din_r[7] ^ crc_din_r[6] ^ crc_din_r[3] ^ crc_dout_r[21] ^ crc_dout_r[27] ^ crc_dout_r[30] ^ crc_dout_r[31];
assign   crc_data[30] = crc_din_r[7] ^ crc_din_r[4] ^ crc_dout_r[22] ^ crc_dout_r[28] ^ crc_dout_r[31];
assign   crc_data[31] = crc_din_r[5] ^ crc_dout_r[23] ^ crc_dout_r[29];

/*--------------------------------------------------*\
                       时序逻辑部分
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        // 复位时初始化CRC寄存器为全1（标准要求）
        crc_dout_r &lt;= 32'hffff_ffff;
    else if (crc_done) 
        // 计算完成时复位寄存器，准备下一次计算
        crc_dout_r &lt;= 32'hffff_ffff;
    else if (crc_din_vld)
        // 有效数据输入时更新CRC值
        crc_dout_r &lt;= crc_data;
    else 
        // 保持当前值
        crc_dout_r &lt;= crc_dout_r;
end


endmodule
</code></pre>
<h5 id="1739">1.7.3.9 代码仿真与验证</h5>
<pre><code class="language-verilog">module tb_crc32_d8();
    reg sys_clk, sys_reset_n;
    reg crc_din_vld;
    reg [7:0] crc_din;
    reg crc_done;
    wire [31:0] crc_dout;

    // 实例化模块
    crc32_d8 u_crc (
        .sys_clk(sys_clk),
        .sys_reset_n(sys_reset_n),
        .crc_din_vld(crc_din_vld),
        .crc_din(crc_din),
        .crc_done(crc_done),
        .crc_dout(crc_dout)
    );

    initial begin
        sys_clk = 0;
        forever #5 sys_clk = ~sys_clk;
    end

    initial begin
        sys_reset_n = 0;
        crc_din_vld = 0;
        crc_din = 0;
        crc_done = 0;
        #20;
        sys_reset_n = 1;

        // 输入数据 0x00
        crc_din_vld = 1;
        crc_din = 8'h00;
        #10;

        // 输入数据 0x01
        crc_din = 8'h01;
        #10;

        // 输入数据 0x02
        crc_din = 8'h02;
        #10;

        // 输入数据 0x03
        crc_din = 8'h03;
        #10;

        crc_din_vld = 0;
        #20;

        // 输出 CRC 值
        $display(&quot;CRC Result: 0x%h&quot;, crc_dout);
        $finish;
    end
endmodule
</code></pre>
<h5 id="17310">1.7.3.10 关键问题回答</h5>
<p><strong>Q1：为何初始值为 <code>0xFFFFFFFF</code>？</strong></p>
<ul>
<li><strong>标准要求</strong>：IEEE 802.3 规定 CRC 寄存器初始化为全1，以提高错误检测能力。</li>
</ul>
<p><strong>Q2：输出为何要取反并反转位序？</strong></p>
<ul>
<li><strong>兼容性</strong>：确保接收方能正确识别校验结果，符合以太网帧格式规范。</li>
</ul>
<p><strong>Q3：组合逻辑表达式能否自动生成？</strong></p>
<ul>
<li><strong>可以</strong>：使用 Python 脚本（如用户提供的代码）基于多项式自动推导，但本模块为专用设计选择手动优化。</li>
</ul>
<p><strong>Q4：如何处理长数据流？</strong></p>
<ul>
<li><strong>流式处理</strong>：连续输入数据字节，每个周期更新 CRC 值，<code>crc_done</code> 用于复位寄存器以开始新计算。</li>
</ul>
<h4 id="174-mac">1.7.4 MAC层发送模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-15 14:38:41
 * @LastEditTime: 2025-02-15 17:17:47
 * @FilePath: rtl/mac_send
 * @Description:以太网mac层数据发送模块，主要功能如下：
 1. 组包：根据以太网协议封装MAC帧，包含前导码、MAC头部、有效数据、CRC校验
 2. 跨时钟域处理：用户时钟(clk)与PHY时钟(phy_tx_clk)间的数据传输
 3. CRC校验计算：实时计算并附加CRC32校验码
 4. ARP交互支持：动态更新目标MAC地址
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module mac_send #(
    parameter     LOCAL_MAC_ADDR    = 48'hffffffffffff,
    parameter     TARGET_MAC_ADDR   = 48'hffffffffffff

 )(
    input               sys_clk         , // 系统时钟信号
    input               phy_tx_clk      , // phy芯片发送时钟

    input               phy_tx_reset    , // phy芯片复位信号
    input               sys_reset_n       , // 系统复位信号

    /*-------与rgmii_send模块交互信号--------*/
    output reg          gmii_tx_data_vld, // 输出给gmii数据有效信号
    output reg  [7:0]   gmii_tx_data    , // 输出给gmii数据信号

    /*-------与ip_send模块交互信号--------*/
    input               mac_tx_data_vld , // 输入mac的数据有效信号
    input               mac_tx_data_last, // 输入mac的数据结束标志
    input       [7:0]   mac_tx_data     , // 输入mac的数据信号
    input       [15:0]  mac_tx_frame_type, // 输入mac的帧类型（如0x0800=IP, 0x0806=ARP）
    input       [15:0]  mac_tx_length   , // 输入mac的数据长度

    /*-------查询arp链表的mac地址--------*/
    input       [47:0]  rd_arp_list_mac , // 查询到的MAC地址
    input               rd_arp_list_mac_vld , // 查询结果有效信号

    /*-------与tx_crc32_d8模块交互信号--------*/
    output reg          tx_crc_din_vld  , // 输出给CRC有效标志信号
    output      [7:0]   tx_crc_din      , // 输出给CRC的数据
    output reg          tx_crc_done     , // 输出给CRC计算完成信号
    input       [31:0]  tx_crc_dout       // CRC计算结果
 );
/*--------------------------------------------------*\
                       状态机信号定义
\*--------------------------------------------------*/
reg [2:0] cur_status, nxt_status;
localparam TX_IDLE = 3'b000;  // 空闲状态
localparam TX_PRE  = 3'b001;  // 前导码阶段
localparam TX_DATA = 3'b010;  // 数据发送阶段
localparam TX_END  = 3'b100;  // 结束阶段（发送CRC）

/*--------------------------------------------------*\
                       FIFO信号定义
\*--------------------------------------------------*/
// frame_fifo：存储目标MAC+帧类型（64位位宽）
reg  [63:0]  frame_din      ; // 输入数据：{目标MAC(48b), 类型(16b)}
reg          frame_wren     ; // 写入使能（用户侧）
wire [63:0]  frame_dout     ; // 输出数据（PHY侧）
reg          frame_rden     ; // 读取使能（PHY侧）
wire         frame_wrfull   ;
wire         frame_rdempty  ;
wire [3:0]   frame_wrcount  ;
wire [3:0]   frame_rdcount  ;

// data_fifo：存储有效数据+结束标志（9位位宽）
reg  [8:0]   data_din       ; // 输入数据：{结束标志(1b), 数据(8b)}
reg          data_wren      ; // 写入使能（用户侧）
wire [8:0]   data_dout      ; // 输出数据（PHY侧）
reg          data_rden      ; // 读取使能（PHY侧）
wire         data_wrfull    ;
wire         data_rdempty   ;
wire [11:0]  data_wrcount   ;
wire [11:0]  data_rdcount   ;

/*--------------------------------------------------*\
                       内部信号
\*--------------------------------------------------*/
reg [10:0] tx_cnt           ; // 发送字节计数器（控制数据组装）
reg [7:0]  send_data        ; // 组装后的发送数据
reg        send_data_en     ; // 发送数据有效
reg        send_data_last   ; // 发送结束标志
reg [7:0]  crc_data         ; // CRC校验数据
reg        crc_data_en      ; // CRC数据有效
reg [2:0]  crc_cnt          ; // CRC字节计数器（4字节分四次发送）
reg [15:0] mac_type         ; // 存储帧类型（跨时钟域同步后）
reg [47:0] send_target_mac  ; // 当前目标MAC（用户侧）
reg [47:0] send_target_mac_cdc; // 同步后的目标MAC（PHY侧）


/*--------------------------------------------------*\
                       目标MAC地址更新逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        send_target_mac &lt;= TARGET_MAC_ADDR; // 复位时初始化为广播地址
    // ARP响应有效时更新目标MAC
    else if (rd_arp_list_mac_vld) 
        send_target_mac &lt;= rd_arp_list_mac;
    // 发送ARP帧时强制使用广播地址
    else if (mac_tx_data_vld &amp;&amp; mac_tx_frame_type == 16'h0806)
        send_target_mac &lt;= 48'hffff_ffff_ffff;
    else 
        send_target_mac &lt;= send_target_mac; // 保持当前值
end

/*--------------------------------------------------*\
                       FIFO写入逻辑（用户侧）
\*--------------------------------------------------*/
// frame_fifo写入：在数据包结束时存入目标MAC和类型
always @(posedge sys_clk) begin
    frame_din  &lt;= {send_target_mac, mac_tx_frame_type}; // 拼接48+16位
    frame_wren &lt;= mac_tx_data_last; // 在包尾写入
end

// data_fifo写入：持续存入有效数据及结束标志
always @(posedge sys_clk) begin
    data_wren &lt;= mac_tx_data_vld;
    data_din  &lt;= {mac_tx_data_last, mac_tx_data}; // 最高位标记包尾
end

/*--------------------------------------------------*\
                       状态机转换逻辑
\*--------------------------------------------------*/
always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) cur_status &lt;= TX_IDLE;
    else cur_status &lt;= nxt_status;
end

always @(*) begin
    nxt_status = cur_status; // 默认保持当前状态
    if (phy_tx_reset) nxt_status = TX_IDLE;
    else case(cur_status)
        TX_IDLE: 
            if (!frame_rdempty) 
                nxt_status = TX_PRE; // FIFO非空则启动发送
            else
                nxt_status = cur_status;
        TX_PRE: 
            nxt_status = TX_DATA; // 前导码阶段仅持续1周期
        TX_DATA: 
            // 当CRC发送完成且是最后一个字节时结束
            if (crc_cnt==3 &amp;&amp; crc_data_en) 
                nxt_status = TX_END;
            else
                nxt_status &lt;= cur_status;
        TX_END: 
            nxt_status = TX_IDLE; // 结束状态返回空闲
        default : nxt_status &lt;= TX_IDLE;
    endcase
end

/*--------------------------------------------------*\
                       数据组包逻辑
\*--------------------------------------------------*/
always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        tx_cnt &lt;= 0;
    else if (cur_status == TX_DATA) 
        tx_cnt &lt;= tx_cnt + 1; // 在数据阶段递增计数器
    else 
        tx_cnt &lt;= 0; // 其他状态复位计数器
end
always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        send_data &lt;= 0;
    else 
        case(tx_cnt)
            0,1,2,3,4,5,6  : send_data &lt;= 8'h55; //// 前导码（7字节0x55）+ 帧起始符（1字节0xD5）
            7              : send_data &lt;= 8'hd5; //帧起始定界符

            8              : send_data &lt;= send_target_mac_cdc[47:40]; // 目标MAC（6字节） 高位先发，9-13依次发送后续字节
            9              : send_data &lt;= send_target_mac_cdc[39:32];
            10             : send_data &lt;= send_target_mac_cdc[31:24];
            11             : send_data &lt;= send_target_mac_cdc[23:16];
            12             : send_data &lt;= send_target_mac_cdc[15:8];
            13             : send_data &lt;= send_target_mac_cdc[7:0];

            14             : send_data &lt;= LOCAL_MAC_ADDR[47:40]; // 源MAC（6字节）
            15             : send_data &lt;= LOCAL_MAC_ADDR[39:32];
            16             : send_data &lt;= LOCAL_MAC_ADDR[31:24];
            17             : send_data &lt;= LOCAL_MAC_ADDR[23:16];
            18             : send_data &lt;= LOCAL_MAC_ADDR[15:8];
            19             : send_data &lt;= LOCAL_MAC_ADDR[7:0];                                              

            20             : send_data &lt;= mac_type[15:8]; // 类型字段（2字节）
            21             : send_data &lt;= mac_type[7:0];  
            default        : send_data &lt;= data_dout[7:0]; // 有效载荷（从data_fifo读取）
        endcase 
end

always @(*) begin
    frame_rden &lt;= cur_status == TX_PRE;
end

always @(posedge phy_tx_clk) begin
    if (frame_rden) begin
        mac_type             &lt;= frame_dout[15:0];
        send_target_mac_cdc  &lt;= frame_dout[63:16];
    end
    else begin
        mac_type             &lt;= mac_type;
        send_target_mac_cdc  &lt;= send_target_mac_cdc;
    end
end

always @(posedge phy_tx_clk) begin
    if (cur_status == TX_DATA &amp;&amp; tx_cnt == 21) 
        data_rden &lt;= 1'b1;
    else if (data_rden &amp;&amp; data_dout[8]) //读到last数据
        data_rden &lt;= 1'b0;
    else 
        data_rden &lt;= data_rden;
end

always @(posedge phy_tx_clk) begin
    if (data_rden &amp;&amp; data_dout[8]) 
        send_data_last &lt;= 1'b1;
    else 
        send_data_last &lt;= 0;
end

always @(posedge phy_tx_clk) begin
    if (phy_tx_reset)
        send_data_en &lt;= 0;
    else if (cur_status == TX_DATA &amp;&amp; tx_cnt == 0) 
        send_data_en &lt;= 1'b1;
    else if (send_data_last) 
        send_data_en &lt;= 0;
    else 
        send_data_en &lt;= send_data_en;
end

/*--------------------------------------------------*\
                       CRC处理逻辑
\*--------------------------------------------------*/
// CRC计算启动：从MAC头开始（tx_cnt=8）
always @(posedge phy_tx_clk) begin
    if (tx_cnt == 8) 
        tx_crc_din_vld &lt;= 1'b1;
    else if (send_data_last) 
        tx_crc_din_vld &lt;= 1'b0;
    else 
        tx_crc_din_vld &lt;= tx_crc_din_vld;
end
// CRC数据输入（与发送数据同步）
assign tx_crc_din = send_data;

always @(posedge phy_tx_clk) begin
    if (crc_data_en &amp;&amp; crc_cnt == 3) 
        tx_crc_done &lt;= 1'b1;
    else 
        tx_crc_done &lt;= 0;
end

always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        crc_cnt &lt;= 0;
    else if (crc_data_en &amp;&amp; crc_cnt == 3) 
        crc_cnt &lt;= 0;
    else if (crc_data_en)
        crc_cnt &lt;= crc_cnt + 1'b1;
    else 
        crc_cnt &lt;= crc_cnt;
end

always @(posedge phy_tx_clk) begin
    if (phy_tx_reset)
        crc_data_en &lt;= 0;
    else if (crc_data_en &amp;&amp; crc_cnt == 3) 
        crc_data_en &lt;= 0;
    else if (send_data_last) 
        crc_data_en &lt;= 1;
    else 
        crc_data_en &lt;= crc_data_en;
end

// CRC结果分四次发送（小端序）
always @(*) begin
    case(crc_cnt)
        0: crc_data = tx_crc_dout[7:0];   // 第1字节（LSB）
        1: crc_data = tx_crc_dout[15:8];
        2: crc_data = tx_crc_dout[23:16];
        3: crc_data = tx_crc_dout[31:24]; // 第4字节（MSB）
    endcase
end

/*--------------------------------------------------*\
                       GMII接口输出
\*--------------------------------------------------*/
always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        gmii_tx_data &lt;= 0;
    else if (send_data_en) 
        gmii_tx_data &lt;= send_data;
    else if (crc_data_en)
        gmii_tx_data &lt;= crc_data;
    else  
        gmii_tx_data &lt;= gmii_tx_data;  
end

always @(posedge phy_tx_clk) begin
    if (phy_tx_reset) 
        gmii_tx_data_vld &lt;= 0;
    else 
        gmii_tx_data_vld &lt;= crc_data_en | send_data_en;
end

/*--------------------------------------------------*\
                       例化FIFO
\*--------------------------------------------------*/
fifo_w64xd16 frame_fifo (
  .rst(phy_tx_reset),                      // input wire rst
  .wr_clk(sys_clk),                // input wire wr_clk
  .rd_clk(phy_tx_clk),                // input wire rd_clk
  .din(frame_din),                      // input wire [63 : 0] din
  .wr_en(frame_wren),                  // input wire wr_en
  .rd_en(frame_rden),                  // input wire rd_en
  .dout(frame_dout),                    // output wire [63 : 0] dout
  .full(frame_wrfull),                    // output wire full
  .empty(frame_rdempty),                  // output wire empty
  .rd_data_count(frame_rdcount),  // output wire [4 : 0] rd_data_count
  .wr_data_count(frame_wrcount)  // output wire [4 : 0] wr_data_count
);

fifo_w9xd4096 data_fifo (
  .rst(phy_tx_reset),                      // input wire rst
  .wr_clk(sys_clk),                // input wire wr_clk
  .rd_clk(phy_tx_clk),                // input wire rd_clk
  .din(data_din),                      // input wire [8 : 0] din
  .wr_en(data_wren),                  // input wire wr_en
  .rd_en(data_rden),                  // input wire rd_en
  .dout(data_dout),                    // output wire [8 : 0] dout
  .full(data_wrfull),                    // output wire full
  .empty(data_rdempty),                  // output wire empty
  .rd_data_count(data_rdcount),  // output wire [11 : 0] rd_data_count
  .wr_data_count(data_wrcount)  // output wire [11 : 0] wr_data_count
);

 endmodule
</code></pre>
<h4 id="175">1.7.5 代码仿真与验证</h4>
<pre><code></code></pre>
<h3 id="18-ipip_receivev">1.8 IP接收模块代码编写：ip_receive.v</h3>
<h4 id="181">1.8.1 模块功能简介</h4>
<p>在IP接收模块中，我们的主要任务仍然是能够正确接收来着MAC接收模块输出的数据，包括<strong>数据有效</strong>、<strong>数据信号</strong>、<strong>数据结束标志信号</strong>，以及能够讲数据解析出IP包头的字段，然后正确将数据传递给下一层UDP接收模块，包括<strong>数据有效信号</strong>、<strong>数据信号</strong>、<strong>数据结束信号</strong>以及<strong>数据长度</strong>信号，在这个模块中，需要判定一下我们的数据类型是UDP协议还是ICMP协议，针对不同的协议类型输出给不同的下一层处理模块（UDP接收和ICMP接收）。其中ICMP协议类型我们在后面会有详细的介绍。</p>
<p>这个模块仍然在系统时钟域中进行处理，不需要将系统时钟与PHY时钟域信号做跨时钟域处理。模块比较简单，在整个大的模块中扮演者一个中间层的角色，总结一下，我们这个模块的主要功能如下：</p>
<ol>
<li><strong>IPv4头部解析</strong>：提取总长度、协议类型、目标IP地址等关键字段。</li>
<li><strong>本地IP过滤</strong>：仅处理目标IP与本地IP匹配的数据包，提升系统安全性。</li>
<li><strong>协议分发</strong>：根据协议类型（UDP/ICMP）将载荷数据路由至对应上层模块。</li>
</ol>
<p><strong>FPGA解析IP层数据包过程动画演示</strong></p>
<pre><code>Step 1: 接收数据流（字节逐个到达）
        ↓
        [0x45][0x00][0x00][0x3C][0x1A][0x2B]... 

Step 2: 通过计数器（rx_cnt）定位字段
        ↓
        rx_cnt=2 → 总长度高字节（0x00）
        rx_cnt=3 → 总长度低字节（0x3C）→ 总长度=60
        rx_cnt=9 → 协议类型（0x11 → UDP）
        rx_cnt=16~19 → 目标IP（0xC0A80102）

Step 3: 校验目标IP是否为本机IP
        ↓
        0xC0A80102 vs LOCAL_IP_ADDR → 匹配则转发

Step 4: 根据协议类型分发数据
        ↓
        UDP → 输出到udp_receive*
        ICMP → 输出到icmp_receive*
</code></pre>
<h4 id="182">1.8.2<strong>核心功能实现</strong></h4>
<pre><code class="language-verilog">/*--------------------------------------------------*\
                       IP包头字段解析
\*--------------------------------------------------*/
// 总长度字段（第2-3字节，大端序）
always @(posedge sys_clk)begin
    case(rx_cnt)
        2:total_length[15:8] &lt;= ip_rx_data;//第2字节-高字节
        3:total_length[7:0] &lt;=ip_rx_data; //第3字节-低字节
    endcase
end

// 协议类型字段（第9字节）
always @(posedge sys_clk)begin
    if(rx_cnt==9)
        ip_protocol &lt;= ip_rx_data;// 记录协议类型
    else
        ip_protocol &lt;= ip_protocol;
end

// 目标IP地址字段（第16-19字节，大端序）
always @(posedge sys_clk)begin
    if(rx_cnt &gt;=16 &amp;&amp; rx_cnt &lt;=19)
        rx_target_ip &lt;= {rx_target_ip[23:0],ip_rx_data};//移位拼接
    else
        rx_target_ip &lt;= rx_target_ip;
end
</code></pre>
<h4 id="183-ip">1.8.3 IP层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-15 19:18:20
 * @LastEditTime: 2025-02-15 20:49:58
 * @FilePath: rtl/ip_receive.v
 * @Description:IP数据包接收和解析模块，主要功能如下：
  1. 解析IPv4包头字段（总长度、协议类型、目标IP地址）
  2. 根据协议类型分发数据包到UDP或ICMP处理模块
  3. 支持本地IP地址过滤（仅处理目标IP为本机的数据包）
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module ip_receive#(
    parameter LOCAL_IP_ADDR = {8'd0,8'd0,8'd0,8'd0}
 )(
    /*-------系统接口--------*/
    input               sys_clk         ,
    input               sys_reset_n     ,

    /*-------MAC层接口--------*/
    input               ip_rx_data_vld  , // IP数据有效信号（与MAC解帧同步）
    input               ip_rx_data_last , // IP数据结束标志（包尾指示）
    input       [7:0]   ip_rx_data      , // IP数据字节（LSB对齐）

    /*-------UDP层接口--------*/
    output reg          udp_rx_data_vld , // UDP数据有效信号
    output reg          udp_rx_data_last, // UDP数据结束标志
    output reg [7:0]    udp_rx_data     , // UDP数据字节
    output reg [15:0]   udp_rx_length   , // UDP数据长度（IP载荷长度）


    /*-------ICMP接口--------*/
    output reg          icmp_rx_data_vld, // ICMP数据有效信号
    output reg          icmp_rx_data_last,// ICMP数据结束标志
    output reg [7:0]    icmp_rx_data    , // ICMP数据字节
    output reg [15:0]   icmp_rx_length    // ICMP数据长度（IP载荷长度）

 );
/*--------------------------------------------------*\
                       定义协议类型
\*--------------------------------------------------*/
localparam UDP_TYPE  = 8'd17; // UDP协议号（RFC 768）
localparam ICMP_TYPE = 8'd1;  // ICMP协议号（RFC 792）

/*--------------------------------------------------*\
                       内部寄存器
\*--------------------------------------------------*/
reg [10:0] rx_cnt; // 接收字节计数器
reg [31:0] rx_target_ip; //目标IP地址寄存器
reg [7:0]  ip_protocol; // 协议类型寄存器
reg [15:0] total_length; // IP包总长度寄存器

/*--------------------------------------------------*\
                       接收字节计数器逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if(!sys_reset_n)
        rx_cnt &lt;= 11'd0;
    else if(ip_rx_data_vld)
        rx_cnt &lt;= rx_cnt + 1'b1;
    else
        rx_cnt &lt;= 11'd0;
end

/*--------------------------------------------------*\
                       IP包头字段解析
\*--------------------------------------------------*/
// 总长度字段（第2-3字节，大端序）
always @(posedge sys_clk)begin
    case(rx_cnt)
        2:total_length[15:8] &lt;= ip_rx_data;//第2字节-高字节
        3:total_length[7:0] &lt;=ip_rx_data; //第3字节-低字节
    endcase
end

// 协议类型字段（第9字节）
always @(posedge sys_clk)begin
    if(rx_cnt==9)
        ip_protocol &lt;= ip_rx_data;// 记录协议类型
    else
        ip_protocol &lt;= ip_protocol;
end

// 目标IP地址字段（第16-19字节，大端序）
always @(posedge sys_clk)begin
    if(rx_cnt &gt;=16 &amp;&amp; rx_cnt &lt;=19)
        rx_target_ip &lt;= {rx_target_ip[23:0],ip_rx_data};//移位拼接
    else
        rx_target_ip &lt;= rx_target_ip;
end

/*--------------------------------------------------*\
                       UDP数据输出逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    // 触发条件：协议是udp+目标IP匹配+超过IP头长度（20字节）
    if(ip_protocol == UDP_TYPE &amp;&amp; rx_target_ip == LOCAL_IP_ADDR &amp;&amp; rx_cnt&gt;=20)begin
        udp_rx_data_vld     &lt;= ip_rx_data_vld;
        udp_rx_data_last    &lt;= ip_rx_data_last;
        udp_rx_data         &lt;= ip_rx_data;
        udp_rx_length       &lt;= total_length;
    end
    else begin //非UDP数据时关闭输出
        udp_rx_data_vld     &lt;= 0;
        udp_rx_data_last    &lt;= 0;
        udp_rx_data         &lt;= 0;
        udp_rx_length       &lt;= 0;
    end
end

/*--------------------------------------------------*\
                       ICMP数据输出逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    // 触发条件：协议是ICMP+目标IP匹配+超过IP头长度
    if(ip_protocol == ICMP_TYPE &amp;&amp; rx_target_ip == LOCAL_IP_ADDR &amp;&amp; rx_cnt&gt;=20)begin
        icmp_rx_data_vld    &lt;= ip_rx_data_vld;
        icmp_rx_data_last   &lt;= ip_rx_data_last;
        icmp_rx_data        &lt;= ip_rx_data;
        icmp_rx_length      &lt;= total_length - 20;
    end
    else begin
        icmp_rx_data_vld    &lt;= 0;  // 非ICMP数据时关闭输出
        icmp_rx_data_last   &lt;= 0;
        icmp_rx_data        &lt;= 0;
        icmp_rx_length      &lt;= 0;
    end 
end

 endmodule
</code></pre>
<h4 id="184">1.8.4 代码仿真与验证</h4>
<h3 id="19-ipip_sendv">1.9 IP发送模块代码编写：ip_send.v</h3>
<h4 id="191">1.9.1 模块功能简介</h4>
<p>该模块是FPGA以太网协议栈中的IP层发送核心单元，主要完成从FPGA中UDP数据发送模块发送的数据传递到IP发送模块中，将数据使用IPv4数据包的封装与发送，符合RFC 791规范。其核心功能包括：</p>
<ol>
<li><strong>IPv4头部组装</strong>：生成版本、总长度、协议类型等字段，支持校验和计算。</li>
<li><strong>协议支持</strong>：支持UDP（协议号17）和ICMP（协议号1）协议封装。</li>
<li><strong>分片标识管理</strong>：自动生成递增的IP标识字段，用于分片重组。</li>
<li><strong>ARP查询触发</strong>：在发送前触发ARP请求，获取目标MAC地址。</li>
<li><strong>数据对齐处理</strong>：通过延迟线实现IP头与载荷数据的时序对齐。</li>
</ol>
<h4 id="192">1.9.2 核心代码</h4>
<p>核心代码分为两个内容：</p>
<p>首先是IP数据从UDP得到的数据添加IP头部并成功送出，在添加IP头部的时候需要对IP数据结构有一个清晰的认识，下面给大家绘制了一下字段结构图：</p>
<pre><code>字节序号 | 字段说明                | 示例值（十六进制）
--------|------------------------|------------------
0       | 版本(4) + 头部长度(5)   | 0x45 → 4: IPv4, 5*4=20字节头
1       | 服务类型                | 0x00（通常忽略）
2-3     | **总长度**             | 0x00 0x3C → 60字节（IP包总长）
4-5     | 标识 (ID)              | 0x1A 0x2B（分片用）
6-7     | 标志 + 分片偏移         | 0x00 0x00（未分片）
8       | TTL                    | 0x40 → 64跳
9       | **协议类型**           | 0x11 → UDP（17）
10-11   | 头部校验和              | 0xA0 0xC0
12-15   | **源IP地址**           | 0xC0 0xA8 0x01 0x01 → 192.168.1.1
16-19   | **目标IP地址**         | 0xC0 0xA8 0x01 0x02 → 192.168.1.2
20-...  | 数据载荷               | UDP/ICMP数据开始
</code></pre>
<p>组包代码如下：</p>
<pre><code>/*--------------------------------------------------*\
                       IP包头组装逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    case(tx_cnt)
        // [0] 版本号(4bit) + 头长度(4bit): IPv4(0x4), 5*4=20字节头(0x5)
        0 : ip_tx_data &lt;= {4'h4, 4'h5}; 

        // [1] 服务类型(TOS)，默认0
        1 : ip_tx_data &lt;= 0; 

        // [2-3] 总长度（大端序）
        2 : ip_tx_data &lt;= ip_tx_length[15:8]; // 高字节
        3 : ip_tx_data &lt;= ip_tx_length[7:0];  // 低字节

        // [4-5] 标识字段（用于分片）
        4 : ip_tx_data &lt;= package_id[15:8]; 
        5 : ip_tx_data &lt;= package_id[7:0];

        // [6-7] 标志(3bit)+分片偏移(13bit)：默认不分片
        6 : ip_tx_data &lt;= {3'b010, 5'h0}; // 010表示允许分片
        7 : ip_tx_data &lt;= 8'h0;

        // [8] 生存时间(TTL)：默认128跳
        8 : ip_tx_data &lt;= 8'h80;

        // [9] 协议类型（UDP/ICMP）
        9 : ip_tx_data &lt;= tx_type_r;

        // [10-11] 头部校验和（大端序）
        10 : ip_tx_data &lt;= ip_head_chack[15:8];
        11 : ip_tx_data &lt;= ip_head_chack[7:0];

        // [12-15] 源IP地址（大端序）
        12 : ip_tx_data &lt;= LOCAL_IP_ADDR[31:24];
        13 : ip_tx_data &lt;= LOCAL_IP_ADDR[23:16];
        14 : ip_tx_data &lt;= LOCAL_IP_ADDR[15:8];
        15 : ip_tx_data &lt;= LOCAL_IP_ADDR[7:0];

        // [16-19] 目标IP地址（大端序）
        16 : ip_tx_data &lt;= TARGET_IP_ADDR[31:24];
        17 : ip_tx_data &lt;= TARGET_IP_ADDR[23:16];
        18 : ip_tx_data &lt;= TARGET_IP_ADDR[15:8];
        19 : ip_tx_data &lt;= TARGET_IP_ADDR[7:0];

        // [20+] 载荷数据（延迟对齐）
        default : ip_tx_data &lt;= tx_data_delay;
    endcase
end
</code></pre>
<p>接着要对组包的数据进行一个<strong>IP头校验和</strong>的处理，IP头校验和是IPv4协议的核心字段所有IPv4数据包必须包含正确的头部校验和。如果校验失败我们会直接丢弃该数据包。若IP头校验缺失，错误数据包可能被错误路由或引发安全问题。</p>
<pre><code class="language-verilog">/*--------------------------------------------------*\
                       IP头校验和计算
\*--------------------------------------------------*/
// 校验和算法：反码求和再取反
// 计算步骤：
// 1. 将IP头按16位分组求和
// 2. 累加进位回卷
// 3. 结果取反
always @(posedge sys_clk) begin
    // 第一组：版本(4)+头长(4)+TOS(8) | 总长度(16)
    add0 &lt;= 16'h4500 + ip_tx_length + package_id;

    // 第二组：标志(3)+偏移(13) | TTL(8)+协议(8)
    add1 &lt;= 16'h4000 + {8'h80, tx_type_r} + LOCAL_IP_ADDR[31:16];

    // 第三组：源IP后半+目标IP
    add2 &lt;= LOCAL_IP_ADDR[15:0] + TARGET_IP_ADDR[31:16] + TARGET_IP_ADDR[15:0];

    // 累加总和
    chack_sum &lt;= add0 + add1 + add2;
end

// 校验和结果处理
always @(posedge sys_clk) begin
    if (!sys_reset_n)
        ip_head_chack &lt;= 0;
    else if (tx_cnt == 5) 
        // 进位回卷：将32位和转换为16位
        ip_head_chack &lt;= chack_sum[31:16] + chack_sum[15:0]; 
    else if (tx_cnt == 6)
        // 最终取反
        ip_head_chack &lt;= ~ip_head_chack; 
end
</code></pre>
<h4 id="193-ip">1.9.3 IP层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-15 20:09:37
 * @LastEditTime: 2025-02-15 20:38:03
 * @FilePath: rtl/ip_send.v
 * @Description:IPv4数据包发送模块，主要功能如下：
  1. 组装完整IPv4包头（含校验和计算）
  2. 支持UDP/ICMP协议封装
  3. 自动生成IP标识字段（用于分片识别）
  4. 集成ARP查询触发机制
  5. 数据延迟对齐处理（IP头与载荷数据时序对齐）
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module ip_send #(
    parameter LOCAL_IP_ADDR = {8'd0,8'd0,8'd0,8'd0}, // 本地IP地址（需配置）
    parameter TARGET_IP_ADDR = {8'd0,8'd0,8'd0,8'd0}  // 目标IP地址（需配置）
 )(
    /*-------系统接口--------*/
    input               sys_clk         ,
    input               sys_reset_n     ,

    /*-------MAC层接口--------*/
    output reg          ip_tx_data_vld  , // IP数据有效信号
    output reg          ip_tx_data_last , // IP数据结束标志
    output reg [15:0]   ip_tx_length    , // IP包总长度（头+载荷）
    output reg [7:0]    ip_tx_data      , // IP数据字节

    /*-------发送端口--------*/
    input               tx_data_vld     , // 数据有效信号
    input               tx_data_last    , // 数据结束标志
    input [7:0]         tx_data         , // 数据字节
    input [15:0]        tx_length       , // 数据长度
    input [7:0]         tx_type         , // 协议类型（UDP=17，ICMP=1）

    /*-------ARP查询接口--------*/
    output reg          rd_arp_list_en  , // ARP查询使能
    output reg [31:0]   rd_arp_list_ip    // 查询的目标IP地址
 );
/*--------------------------------------------------*\
                       内部寄存器定义
\*--------------------------------------------------*/
reg [10:0] tx_cnt;        // 发送字节计数器（最大2048字节）
reg [15:0] package_id;    // IP标识字段（每包递增）
reg [15:0] ip_head_chack; // IP头校验和寄存器
reg [31:0] add0, add1, add2; // 校验和计算中间值
reg [31:0] chack_sum;     // 校验和累加结果
reg [7:0]  tx_type_r;     // 协议类型锁存
reg        tx_data_vld_d0, tx_data_vld_d1; // 有效信号延迟线（打拍）

/*--------------------------------------------------*\
                       移位寄存器接口
\*--------------------------------------------------*/
wire [7:0] tx_data_delay; // 延迟后的上层数据（对齐IP头时序）

/*--------------------------------------------------*\
                       协议类型定义
\*--------------------------------------------------*/
localparam UDP_TYPE  = 8'd17; // UDP协议号
localparam ICMP_TYPE = 8'd1;  // ICMP协议号

/*--------------------------------------------------*\
                       输入信号锁存
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    tx_data_vld_d0 &lt;= tx_data_vld; // 一级延迟
    tx_data_vld_d1 &lt;= tx_data_vld_d0; // 二级延迟
end

// 总长度计算：载荷长度+20字节IP头
always @(posedge sys_clk) begin
    if (tx_data_vld) 
        ip_tx_length &lt;= tx_length + 20; // 存储总长度
end

// 协议类型锁存（保证包头字段一致性）
always @(posedge sys_clk) begin
    if (tx_data_vld) 
        tx_type_r &lt;= tx_type; // 捕获当前协议类型
end

/*--------------------------------------------------*\
                       发送字节计数器
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        tx_cnt &lt;= 0;// 同步复位
    else if (tx_cnt == ip_tx_length - 1) 
        tx_cnt &lt;= 0;// 包尾复位
    else if (tx_data_vld || tx_cnt != 0)
        tx_cnt &lt;= tx_cnt + 1;// 数据有效或计数中递增
end

/*--------------------------------------------------*\
                       输出控制信号生成
\*--------------------------------------------------*/
// 包尾信号生成（提前1周期）
always @(posedge sys_clk) begin
    if (tx_cnt == ip_tx_length - 1) 
        ip_tx_data_last &lt;= 1;
    else 
        ip_tx_data_last &lt;= 0;
end

// 数据有效信号生成（流水线控制）
always @(posedge sys_clk) begin
    if (ip_tx_data_last) 
        ip_tx_data_vld &lt;= 0; // 包尾关闭有效信号
    else if (tx_data_vld) 
        ip_tx_data_vld &lt;= 1; // 数据输入启动发送
end

/*--------------------------------------------------*\
                       IP包头组装逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    case(tx_cnt)
        // [0] 版本号(4bit) + 头长度(4bit): IPv4(0x4), 5*4=20字节头(0x5)
        0 : ip_tx_data &lt;= {4'h4, 4'h5}; 

        // [1] 服务类型(TOS)，默认0
        1 : ip_tx_data &lt;= 0; 

        // [2-3] 总长度（大端序）
        2 : ip_tx_data &lt;= ip_tx_length[15:8]; // 高字节
        3 : ip_tx_data &lt;= ip_tx_length[7:0];  // 低字节

        // [4-5] 标识字段（用于分片）
        4 : ip_tx_data &lt;= package_id[15:8]; 
        5 : ip_tx_data &lt;= package_id[7:0];

        // [6-7] 标志(3bit)+分片偏移(13bit)：默认不分片
        6 : ip_tx_data &lt;= {3'b010, 5'h0}; // 010表示允许分片
        7 : ip_tx_data &lt;= 8'h0;

        // [8] 生存时间(TTL)：默认128跳
        8 : ip_tx_data &lt;= 8'h80;

        // [9] 协议类型（UDP/ICMP）
        9 : ip_tx_data &lt;= tx_type_r;

        // [10-11] 头部校验和（大端序）
        10 : ip_tx_data &lt;= ip_head_chack[15:8];
        11 : ip_tx_data &lt;= ip_head_chack[7:0];

        // [12-15] 源IP地址（大端序）
        12 : ip_tx_data &lt;= LOCAL_IP_ADDR[31:24];
        13 : ip_tx_data &lt;= LOCAL_IP_ADDR[23:16];
        14 : ip_tx_data &lt;= LOCAL_IP_ADDR[15:8];
        15 : ip_tx_data &lt;= LOCAL_IP_ADDR[7:0];

        // [16-19] 目标IP地址（大端序）
        16 : ip_tx_data &lt;= TARGET_IP_ADDR[31:24];
        17 : ip_tx_data &lt;= TARGET_IP_ADDR[23:16];
        18 : ip_tx_data &lt;= TARGET_IP_ADDR[15:8];
        19 : ip_tx_data &lt;= TARGET_IP_ADDR[7:0];

        // [20+] 载荷数据（延迟对齐）
        default : ip_tx_data &lt;= tx_data_delay;
    endcase
end

/*--------------------------------------------------*\
                       IP标识字段管理
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n)
        package_id &lt;= 0; // 复位清零
    else if (ip_tx_data_last)
        package_id &lt;= package_id + 1; // 每包递增
end

/*--------------------------------------------------*\
                       IP头校验和计算
\*--------------------------------------------------*/
// 校验和算法：反码求和再取反
// 计算步骤：
// 1. 将IP头按16位分组求和
// 2. 累加进位回卷
// 3. 结果取反
always @(posedge sys_clk) begin
    // 第一组：版本(4)+头长(4)+TOS(8) | 总长度(16)
    add0 &lt;= 16'h4500 + ip_tx_length + package_id;

    // 第二组：标志(3)+偏移(13) | TTL(8)+协议(8)
    add1 &lt;= 16'h4000 + {8'h80, tx_type_r} + LOCAL_IP_ADDR[31:16];

    // 第三组：源IP后半+目标IP
    add2 &lt;= LOCAL_IP_ADDR[15:0] + TARGET_IP_ADDR[31:16] + TARGET_IP_ADDR[15:0];

    // 累加总和
    chack_sum &lt;= add0 + add1 + add2;
end

// 校验和结果处理
always @(posedge sys_clk) begin
    if (!sys_reset_n)
        ip_head_chack &lt;= 0;
    else if (tx_cnt == 5) 
        // 进位回卷：将32位和转换为16位
        ip_head_chack &lt;= chack_sum[31:16] + chack_sum[15:0]; 
    else if (tx_cnt == 6)
        // 最终取反
        ip_head_chack &lt;= ~ip_head_chack; 
end

/*--------------------------------------------------*\
                        ARP查询触发逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) begin
        rd_arp_list_en &lt;= 0;
        rd_arp_list_ip &lt;= 0;
    end
    // 检测数据有效上升沿（启动ARP查询）
    else if (tx_data_vld_d0 &amp;&amp; ~tx_data_vld_d1) begin
        rd_arp_list_en &lt;= 1'b1;
        rd_arp_list_ip &lt;= TARGET_IP_ADDR;
    end else begin
        rd_arp_list_en &lt;= 0; // 单周期脉冲信号
    end
end

// ********** 数据延迟对齐模块 **********
// 功能：将上层数据延迟20拍，对齐IP头时序
c_shift_ram_0 ip_delay (
  .A(19),       // 延迟深度 = A+1 = 20拍
  .D(tx_data),   // 原始数据输入
  .CLK(sys_clk),     // 同步时钟
  .Q(tx_data_delay) // 延迟后输出
);

 endmodule
</code></pre>
<h4 id="194">1.9.4 代码仿真与验证</h4>
<h3 id="110-udpudp_receivev">1.10 UDP接收模块代码编写：udp_receive.v</h3>
<h4 id="1101-udp">1.10.1 UDP接收模块功能简介</h4>
<p>在这一节中到了UDP模块的编写了，UDP模块是最接近数据与FPGA交互的模块。</p>
<p>FPGA在接收数据的时候，先经过remii_receive模块将rgmii格式的数据转换成gmii格式并经过多层BUFG稳定信号，再经过mac_receive模块将数据去掉mac头部，然后进入ip_receive模块去掉ip头部，将最后的有效数据传递给udp_receive模块去掉udp头部，最后就会被FPGA读取后执行指定的操作了。</p>
<p>在FPGA发送数据的时候，先将FPGA的数据经过udp_send模块添加头部，再进入ip_send添加IP头部，接着进入mac_send添加mac头部，最后经过regmii_send将gmii数据转成rgmii数据并经过多层BUFG用来稳定信号。</p>
<p>这个模块与之前模块的功能很相似，对传进的数据进行剥离数据头部留下有效信号，再将信号传递给下一层即可</p>
<p>在前面的几个模块中已经很详细的讲了如何对数据进行剥离包头，这里就不再赘述，下面给大家这个模块的代码工程</p>
<h4 id="1102-udp">1.10.2 UDP层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-16 14:54:03
 * @LastEditTime: 2025-02-16 16:46:19
 * @FilePath: ttl/udp_receive.vp_receive.v
 * @Description:UDP数据包接收解析模块，主要功能如下：
  1. 过滤指定本地端口的UDP数据包
  2. 剥离UDP头部（8字节）后向下一层传递有效数据
  3. 自动计算有效数据长度
  4. 支持数据流连续传输控制
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module udp_receive#(
    parameter LOCAL_PORT = 16'h8060 // 监听本地端口，默认8060端口
 )(
    /*-------系统信号--------*/
    input           sys_clk             ,
    input           sys_reset_n         ,

    /*-------IP层接口--------*/
    input           udp_rx_data_vld     , // UDP数据有效信号
    input           udp_rx_data_last    , // UDP数据结束标志信号
    input [7:0]     udp_rx_data         , // UDP数据字节
    input [15:0]    udp_rx_length       , // UDP数据总长度

    /*-------应用层端口--------*/
    output reg      app_rx_data_vld     , // 应用数据有效信号
    output reg      app_rx_data_last    , // 应用数据结束标志信号
    output reg [7:0] app_rx_data        , // 应用数据字节
    output reg [15:0] app_rx_length       // 应用数据总长度
 );
/*--------------------------------------------------*\
                       内部信号定义
\*--------------------------------------------------*/
reg [10:0] rx_cnt;
reg [15:0] rx_target_port;

/*--------------------------------------------------*\
                       字节计数器逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) begin
        rx_cnt &lt;= 0;
    end
    else if(udp_rx_data_vld)
        rx_cnt &lt;= rx_cnt + 1'b1;
    else
        rx_cnt &lt;= 0;
end

/*--------------------------------------------------*\
                       目标端口捕获逻辑
\*--------------------------------------------------*/
/*
UDP包头结构（8字节）：
0-1: 源端口 | 2-3: 目标端口 | 4-5: 长度 | 6-7: 校验和
*/
always @(posedge sys_clk)begin
    case (rx_cnt)
       2 : rx_target_port &lt;= udp_rx_data; // 捕获高字节
       3 : rx_target_port &lt;= udp_rx_data; // 捕获低字节
    endcase
end

/*--------------------------------------------------*\
                       应用数据输出逻辑
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    // 触发条件：端口匹配 + 超过UDP头（&gt;=8字节）
    if ((LOCAL_PORT == rx_target_port) &amp;&amp; (rx_cnt &gt;= 8)) begin
        // 直通信号
        app_rx_data_vld  &lt;= udp_rx_data_vld;  // 有效信号
        app_rx_data_last &lt;= udp_rx_data_last; // 结束标志

        // 数据透传
        app_rx_data      &lt;= udp_rx_data;      // 载荷数据

        // 长度计算：总长 - UDP头长度（8字节）
        app_rx_length    &lt;= udp_rx_length - 8;
    end else begin
        // 非目标端口或头部数据时关闭输出
        app_rx_data_vld  &lt;= 0;
        app_rx_data_last &lt;= 0;
        app_rx_data      &lt;= 0;
        app_rx_length    &lt;= 0;
    end
end

 endmodule
</code></pre>
<h4 id="1103">1.10.3 代码仿真与验证</h4>
<h3 id="111-udpudp_sendv">1.11 UDP发送模块代码编写：udp_send.v</h3>
<h4 id="1111-udp">1.11.1 UDP发送模块简介</h4>
<p>这个模块的功能也比较简单，还是用来将数据拼接上UDP头部后输出给下一层</p>
<p>UDP头部格式如下：</p>
<pre><code>0-1: 源端口 | 2-3: 目标端口 | 4-5: 长度 | 6-7: 校验和
</code></pre>
<h4 id="1112-udp">1.11.2 UDP层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-16 15:36:47
 * @LastEditTime: 2025-02-16 16:57:58
 * @FilePath: rtl/udp_send.v
 * @Description:UDP数据发送模块，主要功能如下：
  1. 将用户提供的数据把包成符合UDP协议的数据报
  2. 模块内容自动生成UDP报头，处理数据发送逻辑（包括数据时序对齐，状态机管理和协议控制） 
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module udp_send #(
    parameter LOCAL_PORT    = 16'h0, // 本地端口号
    parameter TARGET_PORT   = 16'h0 // 目标端口号
 ) (
    /*-------系统信号--------*/
    input               sys_clk             ,
    input               sys_reset_n         ,

    /*-------与ip_send模块交互信号--------*/
    output reg          udp_tx_data_vld     , // UDP数据有效信号
    output reg          udp_tx_data_last    , // UDP数据结束标志信号
    output reg [7:0]    udp_tx_data         , // UDP数据
    output reg [15:0]   udp_tx_length       , // UDP数据总长度

    /*-------用户发送端口--------*/
    input               app_tx_data_vld     , // 用户数据有效信号
    input               app_tx_data_last    , // 用户数据结束标志信号
    input [7:0]         app_tx_data         , // 用户数据
    input [15:0]        app_tx_length       , // 用户数据总长度
    output              app_tx_req          , // 用户数据请求信号
    output              app_tx_ready          // 用户准备好信号，表示可以接收用户数据
 );
localparam  READY_CNT_MAX =  50; // 定义一个常数，用于控制app_tx_ready信号的间隔
/*--------------------------------------------------*\
                       内部信号定义
\*--------------------------------------------------*/
reg  [7:0]  ready_cnt          ;   // app_tx_ready信号控制相关的计数器
reg         app_tx_data_vld_r  ;   // 用户数据有效信号寄存器
reg         app_tx_data_last_r ;   // 用户数据末尾信号寄存器
reg  [7:0]  app_tx_data_r      ;   // 用户数据寄存器
reg  [15:0] app_tx_length_r    ;   // 用户数据长度寄存器
reg  [10:0] tx_cnt             ;   // 传输计数器，用于跟踪当前数据传输的进度
wire [7:0]  app_tx_data_delay  ;   // 用于存储延迟后的用户数据

/*--------------------------------------------------*\
                       用户发送请求信号
\*--------------------------------------------------*/
assign app_tx_req = app_tx_data_vld;   // 用户数据请求信号直接来自用户数据有效信号

/*--------------------------------------------------*\
                       打拍，采样用户数据
\*--------------------------------------------------*/
// 这部分逻辑用于在时钟边沿对用户数据信号进行采样和保持，确保数据稳定
always @(posedge sys_clk) begin
    if (app_tx_ready) begin
       app_tx_data_vld_r  &lt;= app_tx_data_vld;   // 采样用户数据有效信号
       app_tx_data_last_r &lt;= app_tx_data_last;  // 采样用户数据末尾信号
       app_tx_data_r      &lt;= app_tx_data;       // 采样用户数据
    end
    else begin
       app_tx_data_vld_r  &lt;= 0;                 // 在非准备状态下，置为无效
       app_tx_data_last_r &lt;= 0;                 // 清除用户数据末尾信号
       app_tx_data_r      &lt;= 0;                 // 清除用户数据
    end
end
// 对用户数据长度进行采样和保持
always @(posedge sys_clk) begin
    if (app_tx_data_vld &amp;&amp; app_tx_ready) 
        app_tx_length_r &lt;= app_tx_length;       // 在用户数据有效且准备好的情况下，采样用户数据长度
    else 
        app_tx_length_r &lt;= app_tx_length_r;     // 保持当前长度
end

/*--------------------------------------------------*\
                       tx_cnt计数器：跟踪传输进度
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        tx_cnt &lt;= 0;                            // 复位时，清零计数器
    else if (app_tx_length_r &lt; 18 &amp;&amp; tx_cnt == 25)  // 数据最小帧长为18 byte，不足时填充至 26 byte
        tx_cnt &lt;= 0;                            // 当用户数据长度小于18，且 tx_cnt 达到25时复位
    else if (app_tx_length_r &gt;= 18 &amp;&amp; tx_cnt == app_tx_length_r + 7)
        tx_cnt &lt;= 0;                            // 当用户数据长度大于等于18，且 tx_cnt 达到 app_tx_length_r +7时复位
    else if (app_tx_data_vld_r || tx_cnt != 0)
        tx_cnt &lt;= tx_cnt + 1;                   // 用户数据有效或计数器非零时递增
    else 
        tx_cnt &lt;= tx_cnt;                       // 保持计数器值
end

/*--------------------------------------------------*\
                       组包：生成UDP数据
\*--------------------------------------------------*/
always @(posedge sys_clk)begin
    if(!sys_reset_n)begin
        udp_tx_data &lt;= 0; // 复位时发送数据清零
    end
    else begin
       case(tx_cnt)
            0 : udp_tx_data &lt;= LOCAL_PORT[15:8];    // 发送本地端口的高字节
            1 : udp_tx_data &lt;= LOCAL_PORT[7:0];     // 发送本地端口的低字节

            2 : udp_tx_data &lt;= TARGET_PORT[15:8];   // 发送目标端口的高字节
            3 : udp_tx_data &lt;= TARGET_PORT[7:0];    // 发送目标端口的低字节

            4 : udp_tx_data &lt;= udp_tx_length[15:8]; // 发送UDP数据长度的高字节
            5 : udp_tx_data &lt;= udp_tx_length[7:0];  // 发送UDP数据长度的低字节

            6 : udp_tx_data &lt;= 0;                  // 填充两个字节的0
            7 : udp_tx_data &lt;= 0;                  // 填充两个字节的0
            default : udp_tx_data &lt;= app_tx_data_delay; // 发送用户数据
       endcase
    end
end
// 根据用户数据长度生成UDP数据长度
always @(posedge sys_clk) begin
    if (app_tx_data_vld_r &amp;&amp; app_tx_length_r &lt;= 18) 
        udp_tx_length &lt;= 26;                      // 当用户数据长度小于18时，UDP数据总长度为26
    else if (app_tx_data_vld_r &amp;&amp;  app_tx_length_r &gt; 18) 
        udp_tx_length &lt;= app_tx_length_r + 8;     // 当用户数据长度大于18时，UDP数据总长度为用户数据长度加8
    else 
        udp_tx_length &lt;= udp_tx_length;           // 保持UDP数据长度
end

// 控制udp_tx_data_vld信号，表示数据有效
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        udp_tx_data_vld &lt;= 0;                     // 复位时，数据无效
    else if (udp_tx_data_last) 
        udp_tx_data_vld &lt;= 0;                     // 数据末尾时，数据无效
    else if (app_tx_data_vld_r)
        udp_tx_data_vld &lt;= 1;                     // 用户数据有效时，数据有效
    else 
        udp_tx_data_vld &lt;= udp_tx_data_vld;       // 保持数据有效信号
end

// 控制udp_tx_data_last信号，表示数据末尾
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        udp_tx_data_last &lt;= 0;                    // 复位时，数据非末尾
    else if (app_tx_length_r &lt; 18 &amp;&amp; tx_cnt == 25) 
        udp_tx_data_last &lt;= 1'b1;                 // 当用户数据长度小于18，且tx_cnt=25时，数据末尾
    else if (app_tx_length_r &gt;= 18 &amp;&amp; tx_cnt == app_tx_length_r + 7)
        udp_tx_data_last &lt;= 1'b1;                 // 当用户数据长度大于等于18，且tx_cnt=app_tx_length_r+7时，数据末尾
    else 
        udp_tx_data_last &lt;= 0;                    // 其他情况为非末尾
end
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        ready_cnt &lt;= 0;
    else if (ready_cnt == READY_CNT_MAX) 
        ready_cnt &lt;= 0;
    else if (app_tx_data_last || ready_cnt != 0)
        ready_cnt &lt;= ready_cnt + 1;
    else 
        ready_cnt &lt;= ready_cnt;
end


// 逻辑复杂，下面是详细注释，我们的复位信号为低电平复位，当按下复位按钮时，sys_reset_n为低，取反后为高，则app_tx_ready被赋值为高电平，表示可以接收用户数据，
// 如果我们没有复位时，当ready_cnt计数到0的时候（或者处理完一组数据后），app_tx_ready被赋值给高电平，表示可以接收用户数据
// 当我们没有复位，并且有一组数据正在发送的时候（ready_cnt不为零），则app_tx_ready被赋值为低，表示没有准备好接收新的一组数据
assign app_tx_ready  = ~sys_reset_n ? 1'b1 : ready_cnt == 0;

/*--------------------------------------------------*\
                       数据延迟模块
\*--------------------------------------------------*/
// 使用移位寄存器对用户数据进行打拍，确保数据在正确的时间点进入发送通道
// 注意：如果A的值为7，udp_tx_data_delay 打拍为8拍
c_shift_ram_0 udp_delay (
  .A(7),      // input wire [5 : 0] A
  .D(app_tx_data_r),      // input wire [7 : 0] D
  .CLK(sys_clk),  // input wire CLK
  .Q(app_tx_data_delay)      // output wire [7 : 0] Q
);


 endmodule
</code></pre>
<h4 id="1113">1.11.3 代码仿真与验证</h4>
<h3 id="112-arp">1.12 ARP介绍</h3>
<p>在我们的程序设计中，arp需要三个模块组成，<code>arp_receive</code>、<code>arp_send</code>,<code>arp_dynamic_list</code>分别是arp接收模块、arp发送模块、arp动态列表模块</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250225160720.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="小白FPGA" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250225160720.png" /></a></p>
<h3 id="113-arparp_receivev">1.13 ARP接收模块代码编写：arp_receive.v</h3>
<h4 id="1131-arp">1.13.1 ARP层接收模块代码</h4>
<pre><code>/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-17 18:00:49
 * @LastEditTime: 2025-02-17 18:08:24
 * @FilePath: rtl/receive.v
 * @Description:用于将 IP 地址映射为物理网络地址(MAC地址)，主要功能如下：
  1. 接收ARP请求数据包
  2. 解析其中的IP和MAC地址信息并判断是否需要生成ARP回复包
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */
module arp_receive #(
    parameter LOCAL_IP_ADDR = {8'd0,8'd0,8'd0,8'd0}  // 本地设备的IP地址，默认为0.0.0.0
)(
    /*-------接收时钟与复位信号--------*/
    input                   app_rx_clk,           // 接收时钟信号
    input                   app_tx_clk,           // 发送时钟信号
    input                   app_rx_reset,         // 接收复位信号，低有效
    input                   app_tx_reset,         // 发送复位信号，低有效

    /*-------接收到的ARP数据--------*/
    input                   arp_rx_data_vld,      // ARP接收数据有效信号
    input                   arp_rx_data_last,     // ARP接收数据最后一位标志
    input       [7:0]       arp_rx_data,          // ARP接收数据

    /*-------处理后的数据输出--------*/
    output reg              rx_source_vld,        // 源MAC地址和源IP地址有效标志
    output reg  [47:0]      rx_source_mac_addr,   // 源MAC地址
    output reg  [31:0]      rx_source_ip_addr,    // 源IP地址

    output reg              arp_reply_req         // ARP回复请求信号
);
/*--------------------------------------------------*\
                       内部寄存器信号定义
\*--------------------------------------------------*/
reg [15:0]      opcode;                // 操作码，1表示ARP请求，2表示ARP应答
reg [31:0]      rx_target_ip;          // 目标IP地址
reg             rx_target_ip_chack;    // 目标IP地址检查标志
reg [5:0]       rx_cnt;                // 接收计数器
reg [47:0]      source_mac_addr;       // 源MAC地址
reg [31:0]      source_ip_addr;        // 源IP地址
reg             arp_reply_active;      // ARP回复活动标志

/*--------------------------------------------------*\
                       rx_cnt:接收计数器逻辑
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_cnt &lt;= 0;  // 重置计数器
    else if (arp_rx_data_vld) 
        rx_cnt &lt;= rx_cnt + 1;  // 如果接收到有效数据，计数器加1
    else 
        rx_cnt &lt;= 0;  // 如果数据无效，计数器重置
end

/*--------------------------------------------------*\
                       操作码的拼接
\*--------------------------------------------------*/
// 根据接收计数器的值，拼接操作码。操作码在 ARP 包的第 6 位和第 7 位。
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        opcode &lt;= 0;
    else if (rx_cnt == 6 || rx_cnt == 7) 
        opcode &lt;= {opcode[7:0], arp_rx_data};  // 拼接操作码
    else 
        opcode &lt;= opcode;  // 保持当前操作码
end

/*--------------------------------------------------*\
                       源MAC地址拼接
\*--------------------------------------------------*/
// 从第 8 位到第 13 位，接收并拼接源 MAC 地址
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        source_mac_addr &lt;= 0;
    else if (rx_cnt &gt;= 8 &amp;&amp; rx_cnt &lt;= 13) 
        source_mac_addr &lt;= {source_mac_addr[39:0], arp_rx_data};  // 拼接源MAC地址
    else 
        source_mac_addr &lt;= source_mac_addr;
end

/*--------------------------------------------------*\
                       目标IP地址的拼接
\*--------------------------------------------------*/
// 从第 24 位到第 27 位，接收并拼接目标 IP 地址。
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_target_ip &lt;= 0;
    else if (rx_cnt &gt;= 24 &amp;&amp; rx_cnt &lt;= 27) 
        rx_target_ip &lt;= {rx_target_ip[23:0], arp_rx_data};  // 拼接目标IP地址
    else 
        rx_target_ip &lt;= rx_target_ip;
end

/*--------------------------------------------------*\
                       目标IP地址检查
\*--------------------------------------------------*/
// 检查接收到的目标 IP 地址是否是本地设备的 IP 地址。如果匹配，则需要生成 ARP 回复请求。
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_target_ip_chack &lt;= 0;
    else if (rx_target_ip == LOCAL_IP_ADDR) 
        rx_target_ip_chack &lt;= 1'b1;  // 如果目标 IP 地址匹配本地地址，设置为 1
    else if (rx_target_ip != LOCAL_IP_ADDR)
        rx_target_ip_chack &lt;= 1'b0;  // 如果目标 IP 地址不匹配本地地址，设置为 0
    else 
        rx_target_ip_chack &lt;= rx_target_ip_chack;
end

/*--------------------------------------------------*\
                       生成ARP回复请求
\*--------------------------------------------------*/
// 如果目标 IP 地址匹配且操作码为 1（ARP 请求），则设置 arp_reply_active 为 1，表示需要生成 ARP 回复包。
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        arp_reply_active &lt;= 0;
    else if (rx_target_ip_chack &amp;&amp; opcode == 1) 
        arp_reply_active &lt;= 1'b1;  // 收到ARP请求包时，激活ARP回复
    else if (!(rx_target_ip_chack &amp;&amp; opcode == 1))
        arp_reply_active &lt;= 0;    // 否则停止ARP回复
end

/*--------------------------------------------------*\
                       将ARP回复数据存入FIFO
\*--------------------------------------------------*/
// 如果接收到的数据是数据包的最后一位，生成 ARP 回复数据并将其写入 FIFO。
always @(posedge app_rx_clk) begin
    if (app_rx_reset) begin
        arp_wren &lt;= 0;
        arp_din  &lt;= 0;
    end
    else if (arp_rx_data_last) begin
        arp_wren &lt;= 1'b1;
        arp_din  &lt;= {arp_reply_active, source_mac_addr, source_ip_addr};  // 生成存储到FIFO的ARP回复数据
    end
    else begin
        arp_wren &lt;= 0;
        arp_din  &lt;= 0;
    end
end

/*--------------------------------------------------*\
                       跨时钟域数据读取
\*--------------------------------------------------*/
// 从 FIFO 中读取 ARP 回复数据并发送到上游模块或硬件。
always @(posedge app_tx_clk) begin
    if (app_tx_reset) begin
        rx_source_vld       &lt;= 0;
        rx_source_mac_addr  &lt;= 0;
        rx_source_ip_addr   &lt;= 0;
        arp_reply_req       &lt;= 0;
    end
    else if (arp_rden) begin
        rx_source_vld       &lt;= 1'b1;
        arp_reply_req       &lt;= arp_dout[80];  // 从 FIFO 中读取 ARP 回复请求信号
        rx_source_mac_addr  &lt;= arp_dout[79:32]; // 从 FIFO 中读取源 MAC 地址
        rx_source_ip_addr   &lt;= arp_dout[31:0];  // 从 FIFO 中读取源 IP 地址
    end  
    else begin
        rx_source_vld       &lt;= 0;
        rx_source_mac_addr  &lt;= 0;
        rx_source_ip_addr   &lt;= 0;
        arp_reply_req       &lt;= 0;
    end
end

/*--------------------------------------------------*\
                       实例化FIFO
\*--------------------------------------------------*/
fifo_w81xd16 arp_rx_fifo (
    .rst(app_rx_reset),        // 输入复位信号
    .wr_clk(app_rx_clk),       // 写时钟信号
    .rd_clk(app_tx_clk),       // 读时钟信号
    .din(arp_din),             // 输入数据
    .wr_en(arp_wren),          // 写使能信号
    .rd_en(arp_rden),          // 读使能信号
    .dout(arp_dout),           // 输出数据
    .full(arp_wrfull),         // FIFO满标志
    .empty(arp_rdempty)        // FIFO空标志
);

endmodule
</code></pre>
<h4 id="1132">1.13.2 代码仿真与验证</h4>
<h3 id="114-arparp_sendv">1.14 ARP发送模块代码编写：arp_send.v</h3>
<h4 id="1141-arp">1.14.1 ARP层发送模块代码</h4>
<pre><code>/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-17 18:53:12
 * @LastEditTime: 2025-02-17 18:56:25
 * @FilePath: rtl/arp_send.v
 * @Description:
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */
 `timescale 1ns / 1ps

module arp_send #(
    parameter     LOCAL_MAC_ADDR    =  48'hffffffffffff,  // 本地MAC地址（默认广播地址）
    parameter     LOCAL_IP_ADDR     =  {8'd0,8'd0,8'd0,8'd0}   // 本地IP地址（默认0.0.0.0）
)(
    input           sys_clk,                    // 时钟信号
    input           sys_reset_n,                  // 复位信号
    input [47:0]    rx_source_mac_addr,     // 接收到的源MAC地址
    input [31:0]    rx_source_ip_addr,      // 接收到的源IP地址
    input           arp_reply_req,          // ARP应答请求信号
    output reg      arp_tx_data_vld,        // ARP数据有效信号
    output reg      arp_tx_data_last,       // ARP数据包最后一字节标志
    output reg [7:0] arp_tx_data,           // 当前发送的ARP数据
    output [15:0]   arp_tx_length           // ARP包的长度（固定为46）
);

    reg [5:0] tx_cnt;                       // 发送数据计数器
    reg [47:0] target_mac_addr;             // 目标MAC地址
    reg [31:0] target_ip_addr;              // 目标IP地址

    assign arp_tx_length = 46;  // ARP包的固定长度

    // 接收到ARP请求时，更新目标MAC地址和目标IP地址
    always @(posedge sys_clk) begin
        if (arp_reply_req &amp;&amp; ~arp_tx_data_vld) begin
            target_mac_addr &lt;= rx_source_mac_addr;
            target_ip_addr  &lt;= rx_source_ip_addr;
        end
    end

    // 计数器tx_cnt控制数据的发送
    always @(posedge sys_clk) begin
        if (!sys_reset_n) 
            tx_cnt &lt;= 0;
        else if (tx_cnt == 45) 
            tx_cnt &lt;= 0;
        else if (arp_reply_req || tx_cnt != 0) 
            tx_cnt &lt;= tx_cnt + 1;
    end

    // 发送数据有效信号控制
    always @(posedge sys_clk) begin
        if (!sys_reset_n) 
            arp_tx_data_vld &lt;= 0;
        else if (arp_reply_req) 
            arp_tx_data_vld &lt;= 1'b1;
        else if (arp_tx_data_last) 
            arp_tx_data_vld &lt;= 1'b0;
    end

    // 数据包最后一字节标志
    always @(posedge sys_clk) begin
        if (!sys_reset_n) 
            arp_tx_data_last &lt;= 0;
        else if (tx_cnt == 45) 
            arp_tx_data_last &lt;= 1'b1;
        else 
            arp_tx_data_last &lt;= 0;
    end

    // 根据计数器值发送各个字节的ARP数据
    always @(posedge sys_clk) begin
        if (!sys_reset_n) 
            arp_tx_data &lt;= 0; 
        else begin
            case(tx_cnt)
                0   : arp_tx_data &lt;= 0;                               // 硬件类型：以太网（0x0001）
                1   : arp_tx_data &lt;= 1;                               // 协议类型：IP（0x0800）
                2   : arp_tx_data &lt;= 8;                               // 硬件地址长度：6字节（MAC地址）
                3   : arp_tx_data &lt;= 0;                               // 协议地址长度：4字节（IP地址）
                4   : arp_tx_data &lt;= 6;                               // 操作码：请求（0x0001）
                5   : arp_tx_data &lt;= 4;                               // 操作码（具体值）
                6   : arp_tx_data &lt;= 0;
                7   : arp_tx_data &lt;= 2;
                8   : arp_tx_data &lt;= LOCAL_MAC_ADDR[47:40];           // 本机MAC地址（高字节）
                9   : arp_tx_data &lt;= LOCAL_MAC_ADDR[39:32];
                10  : arp_tx_data &lt;= LOCAL_MAC_ADDR[31:24];
                11  : arp_tx_data &lt;= LOCAL_MAC_ADDR[23:16];
                12  : arp_tx_data &lt;= LOCAL_MAC_ADDR[15:8];
                13  : arp_tx_data &lt;= LOCAL_MAC_ADDR[7:0];            // 本机MAC地址（低字节）
                14  : arp_tx_data &lt;= LOCAL_IP_ADDR[31:24];            // 本机IP地址（高字节）
                15  : arp_tx_data &lt;= LOCAL_IP_ADDR[23:16];
                16  : arp_tx_data &lt;= LOCAL_IP_ADDR[15:8];
                17  : arp_tx_data &lt;= LOCAL_IP_ADDR[7:0];             // 本机IP地址（低字节）
                18  : arp_tx_data &lt;= target_mac_addr[47:40];          // 目标MAC地址（高字节）
                19  : arp_tx_data &lt;= target_mac_addr[39:32];
                20  : arp_tx_data &lt;= target_mac_addr[31:24];
                21  : arp_tx_data &lt;= target_mac_addr[23:16];
                22  : arp_tx_data &lt;= target_mac_addr[15:8];
                23  : arp_tx_data &lt;= target_mac_addr[7:0];           // 目标MAC地址（低字节）
                24  : arp_tx_data &lt;= target_ip_addr[31:24];           // 目标IP地址（高字节）
                25  : arp_tx_data &lt;= target_ip_addr[23:16];
                26  : arp_tx_data &lt;= target_ip_addr[15:8];
                27  : arp_tx_data &lt;= target_ip_addr[7:0];            // 目标IP地址（低字节）
                default : arp_tx_data &lt;= 0;
            endcase
        end    
    end

endmodule

</code></pre>
<h4 id="1142">1.14.2 代码仿真与验证</h4>
<h3 id="115-arparp_dynamic_listv">1.15 ARP动态列表模块编写arp_dynamic_list.v</h3>
<h4 id="1151-arp">1.15.1 ARP动态列表代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-25 22:07:07
 * @LastEditTime: 2025-02-25 22:22:29
 * @FilePath: rtl/arp_dynamic_list.v
 * @Description:实现ARP协议中的IP-MAC地址动态映射表，用于存储和查询IP地址与MAC地址的对应关系。主要功能如下：
 1. 快速查询：通过并行比对实现IP地址到MAC地址的快速查找，使用并行比对代替软件遍历，查询速度仅需1个时钟周期

 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module arp_dynamic_list(
    input            sys_clk,        // 系统时钟
    input            sys_reset_n,    // 全局复位，低电平有效

    // 更新动态链表的写入端口信号
    input            wr_arp_en,      // ARP表写入使能，高有效
    input  [31:0]    wr_ip_addr,     // 待写入的32位IP地址
    input  [47:0]    wr_mac_addr,    // 待写入的48位MAC地址

    // 查询动态链表的读出端口信号
    input            rd_arp_en,      // ARP表读取使能，高有效
    input  [31:0]    rd_ip_addr,     // 待查询的32位IP地址
    output reg [47:0] rd_mac_addr,    // 查询到的48位MAC地址
    output reg       rd_mac_addr_vld  // MAC地址有效标志
);

// 参数定义
localparam SIZE = 4;     // ARP表深度，支持存储4个IP-MAC映射

// 寄存器定义
reg [31:0] ip_addr_buffer [SIZE-1:0];  // IP地址存储阵列
reg [47:0] mac_addr_buffer[SIZE-1:0];   // MAC地址存储阵列
reg [3:0]  pointer;                     // 循环写入指针（范围0-3）

//==========================================================================
// 主要逻辑部分
//==========================================================================

//---------------------------------------------------------------------
// 时钟同步处理：ARP表写入逻辑
// 功能：1. 复位初始化  2. 更新/添加IP-MAC映射
//---------------------------------------------------------------------
always @(posedge sys_clk) begin
    // 低电平复位初始化
    if (!sys_reset_n) begin 
        ip_addr_buffer[0]  &lt;= 32'd0;    // 初始化IP存储阵列
        ip_addr_buffer[1]  &lt;= 32'd0;
        ip_addr_buffer[2]  &lt;= 32'd0;
        ip_addr_buffer[3]  &lt;= 32'd0;    
        mac_addr_buffer[0] &lt;= 48'd0;    // 初始化MAC存储阵列
        mac_addr_buffer[1] &lt;= 48'd0;
        mac_addr_buffer[2] &lt;= 48'd0;
        mac_addr_buffer[3] &lt;= 48'd0;    
        pointer            &lt;= 4'd0;     // 复位写入指针
    end

    // ARP表写入操作
    else if (wr_arp_en) begin
        case(wr_ip_addr)
            // 存在性检查：如果IP已存在，直接更新对应MAC地址
            ip_addr_buffer[0] : mac_addr_buffer[0] &lt;= wr_mac_addr;
            ip_addr_buffer[1] : mac_addr_buffer[1] &lt;= wr_mac_addr;
            ip_addr_buffer[2] : mac_addr_buffer[2] &lt;= wr_mac_addr;
            ip_addr_buffer[3] : mac_addr_buffer[3] &lt;= wr_mac_addr;

            // 新增条目：IP不存在时写入指针位置，并更新指针
            default : begin
                mac_addr_buffer[pointer] &lt;= wr_mac_addr;  // 写入新MAC
                ip_addr_buffer [pointer] &lt;= wr_ip_addr;  // 写入新IP
                // 指针循环递增（0-&gt;1-&gt;2-&gt;3-&gt;0...）
                pointer &lt;= (pointer == 3'd3) ? 3'd0 : pointer + 3'd1;
            end
        endcase
    end
end

//---------------------------------------------------------------------
// 时钟同步处理：ARP表读取逻辑
// 功能：根据IP地址查询对应的MAC地址
//---------------------------------------------------------------------
always @(posedge sys_clk) begin
    if (!sys_reset_n) begin
        rd_mac_addr &lt;= 48'd0;  // 复位时清除MAC输出
    end  
    else if (rd_arp_en) begin
        case(rd_ip_addr)  // 顺序查询四个存储单元
            ip_addr_buffer[0] : rd_mac_addr &lt;= mac_addr_buffer[0];
            ip_addr_buffer[1] : rd_mac_addr &lt;= mac_addr_buffer[1];
            ip_addr_buffer[2] : rd_mac_addr &lt;= mac_addr_buffer[2];
            ip_addr_buffer[3] : rd_mac_addr &lt;= mac_addr_buffer[3];   
            default :         rd_mac_addr &lt;= 48'd0;  // 未命中返回0
        endcase
    end
end

//---------------------------------------------------------------------
// 时钟同步处理：有效信号生成
// 功能：在读取操作后生成单周期有效信号
//---------------------------------------------------------------------
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        rd_mac_addr_vld &lt;= 1'b0;       // 复位时清除有效标志
    else 
        // 有效信号比读取操作延迟1个时钟周期
        rd_mac_addr_vld &lt;= rd_arp_en;  // 读取使能直接作为有效信号
end

endmodule
</code></pre>
<h3 id="116-icmp">1.16 ICMP协议介绍</h3>
<p>说起icmp协议大家可能比较陌生，但是说到ping命令了，我想在座的同学们应该都再熟悉不过了吧。使用过ping命令的同学都知道，当我们不确定目标主题是否可以连通的时候，都可以拼一下目标。</p>
<p>比如我们想看一下我们的计算机能否与baidu.com联通，我们就可以执行一下ping baidu.com的命令。如果可以连通，那我们会看到这样的显示，表示可以连通，并且平均延迟为15毫秒。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250223221108.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250223221108.png" /></a></p>
<p>今天咱们就一起来学习一下拼命令背后的协议icmp协议。ICMP协议简单来说，它的作用就是帮助网络管理员检测网络中发生的各种问题，然后根据问题原因做出诊断和解决。</p>
<h4 id="1161-icmp">1.16.1 ICMP协议分类</h4>
<p>从大类上来分，它主要是两大块的功能。</p>
<p>一是询问报告，比如询问一下目标主机是否可以连通并做出回答，我们常用的Ping命令就是用这个功能来实现的。</p>
<p>二是用来做差错报告，比如网关发现目标网络不可谈，或者目标主机发现访问的UDP端口不可用，需要把错误报告给原主机。Tracroot这个工序就是用这个功能来实现的。</p>
<p>我们这个项目中ICMP协议就是只是用到第一个功能用来检查我们的电脑是否与FPGA开发板联通。</p>
<h4 id="1162-icmp">1.16.2. ICMP数据包的结构与实现流程</h4>
<p>ICMP数据包包含以下几个部分：</p>
<ul>
<li><strong>ICMP头部</strong>：包括类型（Type）、代码（Code）、校验和（Checksum）、标识符（Identifier）和序列号（Sequence Number）。</li>
<li><strong>数据部分</strong>：通常用于携带额外的信息，如时间戳或用户数据。</li>
</ul>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250223221621.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250223221621.png" /></a></p>
<h3 id="117-icmpicmp_receivev">1.17 ICMP接收模块代码编写：icmp_receive.v</h3>
<h4 id="1171-icmp">1.17.1 ICMP层接收模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-17 17:23:58
 * @LastEditTime: 2025-02-17 17:35:19
 * @FilePath: rtl/icmp_receive.v
 * @Description:收到数据后通过FIFO缓存数据，实现跨时钟域处理，并且将接收到的数据包识别符和序列号提取出来并输出
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */
 module icmp_receive (
    /*-------用户端口信号--------*/
    input                   app_rx_clk;            // 接收时钟
    input                   app_tx_clk;            // 发送时钟
    input                   app_rx_reset;          // 接收复位信号
    input                   app_tx_reset;          // 发送复位信号

    /*-------ICMP输入端口信号--------*/
    input                   icmp_rx_data_vld;      // ICMP接收数据有效信号
    input                   icmp_rx_data_last;     // ICMP接收数据的最后一位标志
    input [7:0]             icmp_rx_data;          // ICMP接收数据
    input [15:0]            icmp_rx_length;        // ICMP接收数据包的长度

    /*-------ICMP输出端口信号--------*/
    output reg              icmp_reply_req;        // ICMP回复请求
    output reg [15:0]       icmp_rx_identify;      // ICMP包的标识符
    output reg [15:0]       icmp_rx_sequence;      // ICMP包的序列号
 );
/*--------------------------------------------------*\
                       内部寄存器和信号
\*--------------------------------------------------*/
reg [10:0]             rx_cnt;               // 接收计数器
reg [15:0]             rx_identify;          // 临时存储ICMP的标识符
reg [15:0]             rx_sequence;          // 临时存储ICMP的序列号
reg [7:0]              imcp_type;            // 临时存储ICMP类型
reg [31:0]             icmp_din;             // 用于FIFO的数据输入
reg                    icmp_wren;            // FIFO写使能信号
wire [31:0]            icmp_dout;            // FIFO数据输出
wire                   icmp_rden;            // FIFO读使能信号
wire                   icmp_wrfull;          // FIFO写满标志
wire                   icmp_rdempty;         // FIFO读空标志

/*--------------------------------------------------*\
                       接收计数器逻辑
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_cnt &lt;= 0;                         // 如果复位信号有效，则清零计数器
    else if (icmp_rx_data_vld) 
        rx_cnt &lt;= rx_cnt + 1;               // 数据有效时，计数器递增
    else 
        rx_cnt &lt;= 0;                         // 如果数据无效，则计数器清零
end

/*--------------------------------------------------*\
                       ICMP类型的提取
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        imcp_type &lt;= 0;                  // 复位时清空ICMP类型
    else if (rx_cnt == 0) 
        imcp_type &lt;= icmp_rx_data;       // 第一个字节（ICMP数据包的类型）
    else 
        imcp_type &lt;= imcp_type;          // 保持原值
end

/*--------------------------------------------------*\
                       ICMP标识符提取
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_identify &lt;= 0;                // 复位时清空标识符
    else if (rx_cnt == 4 || rx_cnt == 5) 
        rx_identify &lt;= {rx_identify[7:0], icmp_rx_data};  // 从第4、第5字节拼接标识符
    else 
        rx_identify &lt;= rx_identify;      // 保持原值
end

/*--------------------------------------------------*\
                       ICMP序列号提取
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) 
        rx_sequence &lt;= 0;                // 复位时清空序列号
    else if (rx_cnt == 6 || rx_cnt == 7) 
        rx_sequence &lt;= {rx_sequence[7:0], icmp_rx_data};  // 从第6、第7字节拼接序列号
    else 
        rx_sequence &lt;= rx_sequence;      // 保持原值
end

/*--------------------------------------------------*\
                       FIFO 存储 ICMP 数据
\*--------------------------------------------------*/
always @(posedge app_rx_clk) begin
    if (app_rx_reset) begin
        icmp_wren &lt;= 0;                  // 复位时不写入FIFO
        icmp_din &lt;= 0;                   // 清空FIFO输入数据
    end  
    else begin
        icmp_wren &lt;= icmp_rx_data_last;  // 如果是最后一个数据字节，写入FIFO
        icmp_din &lt;= {rx_identify, rx_sequence};  // 将标识符和序列号一起写入FIFO
    end
end

/*--------------------------------------------------*\
             跨时钟域处理（从接收时钟到发送时钟）
\*--------------------------------------------------*/
always @(posedge app_tx_clk) begin
    if (app_tx_reset) begin
        icmp_reply_req &lt;= 0;            // 复位时不请求回复
        icmp_rx_identify &lt;= 0;          // 清空ICMP标识符
        icmp_rx_sequence &lt;= 0;          // 清空ICMP序列号
    end 
    else if (icmp_rden) begin
        icmp_reply_req &lt;= 1;            // 如果FIFO读取有效数据，设置回复请求
        icmp_rx_identify &lt;= icmp_dout[31:16];  // 提取标识符
        icmp_rx_sequence &lt;= icmp_dout[15:0];   // 提取序列号
    end 
    else begin
        icmp_reply_req &lt;= 0;            // 否则不请求回复
        icmp_rx_identify &lt;= 0;          // 清空标识符
        icmp_rx_sequence &lt;= 0;          // 清空序列号
    end     
end

/*--------------------------------------------------*\
                       FIFO 实例
\*--------------------------------------------------*/
fifo_w32xd16_async icmp_rx_fifo (
  .rst(app_rx_reset),        // 输入复位信号
  .wr_clk(app_rx_clk),       // 写时钟信号（接收时钟）
  .rd_clk(app_tx_clk),       // 读时钟信号（发送时钟）
  .din(icmp_din),            // 输入数据（标识符和序列号）
  .wr_en(icmp_wren),         // 写使能信号
  .rd_en(icmp_rden),         // 读使能信号
  .dout(icmp_dout),          // 输出数据（标识符和序列号）
  .full(icmp_wrfull),        // FIFO写满标志
  .empty(icmp_rdempty)       // FIFO读空标志
);

 endmodule
</code></pre>
<h4 id="1172">1.17.2 代码仿真与验证</h4>
<h3 id="118-icmpicmp_sendv">1.18 ICMP发送模块代码编写：icmp_send.v</h3>
<h4 id="1181-icmp">1.18.1 ICMP层发送模块代码</h4>
<pre><code class="language-verilog">/*
 * ****************************************Copyright (c)***********************************
 * @Date: 2025-02-17 17:46:37
 * @LastEditTime: 2025-02-17 17:55:14
 * @FilePath: rtl/icmp_send.v
 * @Description:用于按照 ICMP 协议规则生成并回复 Echo 回复包，ICMP Echo 请求包和回复包的格式大致相同，区别主要在于其中的类型字段。主要功能如下：
 1. 接收并保存请求信息：当收到 ICMP 回复请求时，模块会从请求中提取标识符和序列号。
 2. 数据字节生成与发送：根据 ICMP 协议的格式（类型、代码、校验和、标识符、序列号等），模块将数据字节逐个生成并发送。
 3. 校验和计算：计算 ICMP 包的校验和，保证数据的完整性。
 4. 发送控制：通过计数器和状态信号控制数据的发送顺序，确保数据的正确发送。
 * Copyright (c) 2025 by 硅农公社, All Rights Reserved.
 *
 * 哔哩哔哩：https://space.bilibili.com/500610348?spm_id_from=333.1007.0.0
 * ****************************************************************************************
 */

 module icmp_send(
    /*-------系统端口信号--------*/
    input                   sys_clk;               // 输入时钟信号
    input                   sys_reset_n;             // 复位信号

    /*-------ICMP接收端口信号--------*/
    input                   icmp_reply_req;    // ICMP 回复请求信号
    input      [15:0]      icmp_rx_identify;  // 接收到的 ICMP 包标识符
    input      [15:0]      icmp_rx_sequence;  // 接收到的 ICMP 包序列号

    /*-------ICMP发送端口信号--------*/
    output reg              icmp_tx_data_vld;  // ICMP 发送数据有效信号
    output reg              icmp_tx_data_last; // ICMP 发送数据最后一位标志
    output reg [7:0]        icmp_tx_data;      // ICMP 发送数据字节
    output     [15:0]       icmp_tx_length;    // ICMP 发送数据包的长度
 );
 /*--------------------------------------------------*\
                        内部寄存器和信号
 \*--------------------------------------------------*/
reg [5:0]              tx_cnt;            // 发送计数器，用于控制数据发送的顺序
reg [15:0]             icmp_tx_identify;  // ICMP 回复包的标识符
reg [15:0]             icmp_tx_sequence;  // ICMP 回复包的序列号
reg [31:0]             icmp_tx_chack;     // ICMP 校验和

/*--------------------------------------------------*\
            处理 ICMP 回复请求,获取标识符和序列号
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) begin
        icmp_tx_identify &lt;= 0;
        icmp_tx_sequence &lt;= 0;
    end
    else if (icmp_reply_req &amp;&amp; ~icmp_tx_data_vld) begin
        icmp_tx_identify &lt;= icmp_rx_identify;   // 从接收到的数据包中获取标识符
        icmp_tx_sequence &lt;= icmp_rx_sequence;   // 从接收到的数据包中获取序列号
    end
    else begin
        icmp_tx_identify &lt;= icmp_tx_identify;   // 保持原值
        icmp_tx_sequence &lt;= icmp_tx_sequence;   // 保持原值
    end 
end

/*--------------------------------------------------*\
                       发送计数器控制
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        tx_cnt &lt;= 0;                            // 复位时，计数器归零
    else if (tx_cnt == 39)                      // 如果已经发送了40个字节（ICMP数据包长度）
        tx_cnt &lt;= 0;                            // 重新开始
    else if (icmp_reply_req || tx_cnt != 0)     // 当有回复请求或计数器未清零时，计数器递增
        tx_cnt &lt;= tx_cnt + 1;
    else 
        tx_cnt &lt;= tx_cnt;                       // 保持计数器值
end

/*--------------------------------------------------*\
                       发送数据有效信号控制
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        icmp_tx_data_vld &lt;= 0;                // 复位时，发送数据有效信号为 0
    else if (icmp_tx_data_last) 
        icmp_tx_data_vld &lt;= 0;                // 如果是最后一个数据字节，数据无效
    else if (icmp_reply_req)
        icmp_tx_data_vld &lt;= 1'b1;             // 当有 ICMP 回复请求时，数据有效
    else 
        icmp_tx_data_vld &lt;= icmp_tx_data_vld; // 保持原值
end

/*--------------------------------------------------*\
                       发送数据最后一位标志控制
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        icmp_tx_data_last &lt;= 0;                  // 复位时，最后一位标志为 0
    else if (tx_cnt == 39) 
        icmp_tx_data_last &lt;= 1'b1;               // 发送完40个字节后，标志置为 1
    else 
        icmp_tx_data_last &lt;= 0;                  // 其他情况下，标志置为 0
end

/*--------------------------------------------------*\
                       校验和计算
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        icmp_tx_chack &lt;= 0;                         // 复位时，校验和为0
    else if (icmp_reply_req) 
        icmp_tx_chack &lt;= icmp_rx_identify + icmp_rx_sequence;  // 初始校验和为标识符和序列号之和
    else if (tx_cnt == 1)
        icmp_tx_chack &lt;= ~(icmp_tx_chack[31:16] + icmp_tx_chack[15:0]); // 计算校验和
    else 
        icmp_tx_chack &lt;= icmp_tx_chack;             // 保持原值
end

/*--------------------------------------------------*\
                       数据字节生成
\*--------------------------------------------------*/
always @(posedge sys_clk) begin
    if (!sys_reset_n) 
        icmp_tx_data &lt;= 0;
    else begin
        case(tx_cnt)
            0  : icmp_tx_data &lt;= 0;                        // 类型字节（0表示应答）
            1  : icmp_tx_data &lt;= 0;                        // 代码字节（默认为0）
            2  : icmp_tx_data &lt;= icmp_tx_chack[15:8];      // 校验和的高字节
            3  : icmp_tx_data &lt;= icmp_tx_chack[7:0];       // 校验和的低字节
            4  : icmp_tx_data &lt;= icmp_tx_identify[15:8];   // 标识符的高字节
            5  : icmp_tx_data &lt;= icmp_tx_identify[7:0];    // 标识符的低字节
            6  : icmp_tx_data &lt;= icmp_tx_sequence[15:8];   // 序列号的高字节
            7  : icmp_tx_data &lt;= icmp_tx_sequence[7:0];    // 序列号的低字节
            default : icmp_tx_data &lt;= 0;                   // 默认值
        endcase
    end    
end


 endmodule
</code></pre>
<h4 id="1182">1.18.2 代码仿真与验证</h4>
<h1 id="2_2">2. 以太网数据回环实验</h1>
<h1 id="3-lcd">3. LCD屏幕驱动显示</h1>
<h2 id="31-vga">3.1 VGA驱动显示</h2>
<h2 id="32ddr3">3.2DDR3图像缓存</h2>
<h2 id="33-ddr3lcd">3.3 基于DDR3存储显示LCD彩条</h2>
<h1 id="4-adc">4. ADC采集存储系统</h1>
<h1 id="5-udp">5. 基于UDP协议的实时画面显示</h1>
<h1 id="_8">参考教程</h1>
<p>笔记内容图片部分使用互联网图片，图片均会标明来源，如有侵权，请联系作者进行删除改正</p>
<p>致谢：</p>
<ol>
<li>小白FPGA课程</li>
<li>哔哩哔哩：野火FPGA</li>
<li>CSDN</li>
<li>博客园</li>
<li>Kimi人工智能帮助编写文章内容</li>
<li><a href="https://www.intel.cn/content/www/cn/zh/docs/programmable/683634/20-4/rmii-and-rgmii-phy-interfaces.html">英特尔5.1.7.1.2. RMII和RGMII PHY接口</a></li>
<li><a href="https://www.deepseek.com/">DeepSeek | 深度求索</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ol3spWkhmugTNHBdpwAtLw">微信公众平台</a></li>
</ol>
<h1 id="1-phydatasheet">附录1 PHY原理图即DataSheet说明</h1>
<p>参考链接：<a href="https://www.bilibili.com/video/BV1nQ4y1Z7zN/?p=136&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=0b1c8d67ad5702d24738bcdbd2cca82c">136-第三十八讲-以太网数据回环实验（实战演练（一））_哔哩哔哩_bilibili</a></p>
<p>因为是原理图和手册的讲解，使用图文的方式很难给大家讲清楚里面的内容，请配合观看视频进行学习巩固。</p>
<p><a class="glightbox" href="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250207220226.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="米联客FPGA原理图截屏" src="https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_mig20250207220226.png" /></a></p>
<p>参考手册下载地址：https://raw.githubusercontent.com/zikwq/Blog_Pic/main/new_migRealtek%20RTL8211F(D)(I)-CG%20DataSheet%201.9.pdf</p>
<h1 id="2_3">附录2 以外网相关协议文档阅读</h1>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../SPI%E5%8D%8F%E8%AE%AE/" class="md-footer__link md-footer__link--prev" aria-label="上一页: SPI协议">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                SPI协议
              </div>
            </div>
          </a>
        
        
          
          <a href="../FPGA%E5%AE%9E%E7%8E%B0CAN%E9%80%9A%E4%BF%A1/" class="md-footer__link md-footer__link--next" aria-label="下一页: FPGA实现CAN通信">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                FPGA实现CAN通信
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      添加统计信息 </a>
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://zikwq.github.io/" target="_blank" rel="noopener" title="友链 &amp; 导航站" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M384 48c8.8 0 16 7.2 16 16v384c0 8.8-7.2 16-16 16H96c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16zM96 0C60.7 0 32 28.7 32 64v384c0 35.3 28.7 64 64 64h288c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zm144 256a64 64 0 1 0 0-128 64 64 0 1 0 0 128m-32 32c-44.2 0-80 35.8-80 80 0 8.8 7.2 16 16 16h192c8.8 0 16-7.2 16-16 0-44.2-35.8-80-80-80zM512 80c0-8.8-7.2-16-16-16s-16 7.2-16 16v64c0 8.8 7.2 16 16 16s16-7.2 16-16zm-16 112c-8.8 0-16 7.2-16 16v64c0 8.8 7.2 16 16 16s16-7.2 16-16v-64c0-8.8-7.2-16-16-16m16 144c0-8.8-7.2-16-16-16s-16 7.2-16 16v64c0 8.8 7.2 16 16 16s16-7.2 16-16z"/></svg>
    </a>
  
    
    
    
    
    <a href="None" target="_blank" rel="noopener" title="书摘" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M0 48C0 21.5 21.5 0 48 0v441.4l130.1-92.9c8.3-6 19.6-6 27.9 0l130 92.9V48H48V0h288c26.5 0 48 21.5 48 48v440c0 9-5 17.2-13 21.3s-17.6 3.4-24.9-1.8L192 397.5l-154.1 110c-7.3 5.2-16.9 5.9-24.9 1.8S0 497 0 488z"/></svg>
    </a>
  
    
    
    
    
    <a href="None" target="_blank" rel="noopener" title="资源仓库" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M64 464c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16h160v80c0 17.7 14.3 32 32 32h80v288c0 8.8-7.2 16-16 16zM64 0C28.7 0 0 28.7 0 64v384c0 35.3 28.7 64 64 64h256c35.3 0 64-28.7 64-64V154.5c0-17-6.7-33.3-18.7-45.3l-90.6-90.5C262.7 6.7 246.5 0 229.5 0zm56 256c-13.3 0-24 10.7-24 24s10.7 24 24 24h144c13.3 0 24-10.7 24-24s-10.7-24-24-24zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24h144c13.3 0 24-10.7 24-24s-10.7-24-24-24z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy", "content.action.edit", "navigation.tracking", "navigation.tabs", "navigation.footer", "navigation.sections", "navigation.indexes", "toc.follow", "navigation.top", "search.suggest"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="../../javascripts/tex-mml-chtml.js"></script>
      
        <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      
        <script src="../../stylesheets/extra.css"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>